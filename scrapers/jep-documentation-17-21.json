[
  {
    "url": "https://openjdk.org/jeps/422",
    "title": "JEP 422: Linux/RISC-V Port",
    "content": {
      "title": "JEP 422: Linux/RISC-V Port",
      "summary": "JEP 422: Linux/RISC-V Port JEP 422: Linux/RISC-V Port Author fyang Owner Fei Yang Type Feature Scope Implementation Status Closed&#8201;/&#8201;Delivered Release 19 Component hotspot&#8201;/&#8201;other Discussion riscv dash port dash dev at openjdk dot java dot net Effort L Duration S Reviewed by Aleksey Shipilev Endorsed by Vladimir Kozlov Created 2021/11/08 08:11 Updated 2024/06/06 15:39 Issue 8276797 Summary Port the JDK to Linux/RISC-V. Motivation RISC-V is a free and open-source RISC instr",
      "sections": {
        "Summary": "Port the JDK to Linux/RISC-V.",
        "Motivation": "RISC-V is a free and open-source RISC instruction set architecture (ISA) designed originally at the University of California, Berkeley, and now developed collaboratively under the sponsorship of RISC-V International . It is already supported by a wide range of language toolchains. With the increasing availability of RISC-V hardware, a port of the JDK would be valuable.",
        "Description": "The RISC-V ISA is actually a family of related ISAs, of which there are currently four base ISAs. Each base ISA can be configured with one or more standard extensions. The Linux/RISC-V port will only support the RV64GV configuration of RISC-V, which is a general-purpose 64-bit ISA that includes vector instructions. In the future we may consider supporting other RISC-V configurations such as, for example, a general-purpose 32-bit configuration (RV32G). The port will support the following HotSpot subsystems: The template interpreter, The C1 (client) JIT compiler, The C2 (server) JIT compiler, and All current mainline GCs, including ZGC and Shenandoah. The focus of this JEP is not the porting effort itself, which is nearly complete, but rather the integration of the port into the JDK main-line repository. Currently we have a number of trivial changes in the shared part of JDK. These are mostly #ifdef s that include the relevant platform-specific files. There are a few changes of other kin",
        "Testing": "The port passes jtreg tiers 1&#8211;4 and jcstress tests on a HiFive Unmatched development board. We also regularly carry out SPECjbb and SPECjvm benchmark tests. Huawei Technologies, Alibaba, and Red Hat regularly build and test this port on Linux/RISC-V as well as on the currently-supported JDK platforms to ensure that no regressions are introduced which break the existing platforms. Huawei Technologies is committed to support fully (i.e., regularly update, enhance, and test) the code introduced by this effort.",
        "Risks and Assumptions": "There are potentially some issues with the availablility of RISC-V hardware for this work, but we hope that it will become widely available in the near future. Installing Contributing Sponsoring Developers' Guide Vulnerabilities JDK GA/EA Builds Mailing lists Wiki &#183; IRC Mastodon Bluesky Bylaws &#183; Census Legal Workshop JEP Process Source code GitHub Mercurial Tools Git jtreg harness Groups (overview) Adoption Build Client Libraries Compatibility &amp;",
        "Specification": "Review Compiler Conformance Core Libraries Governing Board HotSpot IDE Tooling &amp; Support Internationalization JMX Members Networking Porters Quality Security Serviceability Vulnerability Web Projects ( overview , archive ) Amber Babylon CRaC Code Tools Coin Common VM Interface Developers' Guide Device I/O Duke Galahad Graal IcedTea JDK 8 Updates JDK 9 JDK (&#8230;, 24 , 25 , 26 ) JDK Updates JMC Jigsaw Kona Lanai Leyden Lilliput Locale Enhancement Loom Memory Model Update Metropolis Multi-Language VM Nashorn New I/O OpenJFX Panama Penrose Port: AArch32 Port: AArch64 Port: BSD Port: Haiku Port: Mac OS X Port: MIPS Port: Mobile Port: PowerPC/AIX Port: RISC-V Port: s390x SCTP Shenandoah Skara Sumatra Tsan Valhalla Verona VisualVM Wakefield Zero ZGC &#169; 2025 Oracle Corporation and/or its affiliates Terms of Use &#183; License: GPLv2 &#183; Privacy &#183; Trademarks"
      },
      "fullText": "JEP 422: Linux/RISC-V Port JEP 422: Linux/RISC-V Port Author fyang Owner Fei Yang Type Feature Scope Implementation Status Closed&#8201;/&#8201;Delivered Release 19 Component hotspot&#8201;/&#8201;other Discussion riscv dash port dash dev at openjdk dot java dot net Effort L Duration S Reviewed by Aleksey Shipilev Endorsed by Vladimir Kozlov Created 2021/11/08 08:11 Updated 2024/06/06 15:39 Issue 8276797 Summary Port the JDK to Linux/RISC-V. Motivation RISC-V is a free and open-source RISC instruction set architecture (ISA) designed originally at the University of California, Berkeley, and now developed collaboratively under the sponsorship of RISC-V International . It is already supported by a wide range of language toolchains. With the increasing availability of RISC-V hardware, a port of the JDK would be valuable. Description The RISC-V ISA is actually a family of related ISAs, of which there are currently four base ISAs. Each base ISA can be configured with one or more standard extensions. The Linux/RISC-V port will only support the RV64GV configuration of RISC-V, which is a general-purpose 64-bit ISA that includes vector instructions. In the future we may consider supporting other RISC-V configurations such as, for example, a general-purpose 32-bit configuration (RV32G). The port will support the following HotSpot subsystems: The template interpreter, The C1 (client) JIT compiler, The C2 (server) JIT compiler, and All current mainline GCs, including ZGC and Shenandoah. The focus of this JEP is not the porting effort itself, which is nearly complete, but rather the integration of the port into the JDK main-line repository. Currently we have a number of trivial changes in the shared part of JDK. These are mostly #ifdef s that include the relevant platform-specific files. There are a few changes of other kinds, but again these are guarded by #ifdef RISCV . Thus, the risk to other platforms is low. There are also changes to the build machinery of the JDK to add appropriate definitions for endianness, word size, and so on. Again, these should not affect other platforms. The current diff between JDK mainline and RISC-V port project can be obtained by: $ git clone https://github.com/openjdk/riscv-port riscv-port $ cd riscv-port $ git diff master..riscv-port An automatically generated webrev for that difference is available here . Testing The port passes jtreg tiers 1&#8211;4 and jcstress tests on a HiFive Unmatched development board. We also regularly carry out SPECjbb and SPECjvm benchmark tests. Huawei Technologies, Alibaba, and Red Hat regularly build and test this port on Linux/RISC-V as well as on the currently-supported JDK platforms to ensure that no regressions are introduced which break the existing platforms. Huawei Technologies is committed to support fully (i.e., regularly update, enhance, and test) the code introduced by this effort. Risks and Assumptions There are potentially some issues with the availablility of RISC-V hardware for t"
    }
  },
  {
    "url": "https://openjdk.org/jeps/439",
    "title": "JEP 439: Generational ZGC",
    "content": {
      "title": "JEP 439: Generational ZGC",
      "summary": "JEP 439: Generational ZGC JEP 439: Generational ZGC Owner Stefan Karlsson Type Feature Scope JDK Status Closed&#8201;/&#8201;Delivered Release 21 Component hotspot&#8201;/&#8201;gc Discussion hotspot dash gc dash dev at openjdk dot org Effort XL Duration XL Relates to JEP 377: ZGC: A Scalable Low-Latency Garbage Collector (Production) JEP 474: ZGC: Generational Mode by Default JEP 490: ZGC: Remove the Non-Generational Mode Reviewed by Erik Helin, Erik &#214;sterlund, Vladimir Kozlov Endorsed by ",
      "sections": {
        "Summary": "Improve application performance by extending the Z Garbage Collector ( ZGC ) to maintain separate generations for young and old objects. This will allow ZGC to collect young objects &#8212; which tend to die young &#8212; more frequently.",
        "Goals": "Applications running with Generational ZGC should enjoy Lower risks of allocations stalls, Lower required heap memory overhead, and Lower garbage collection CPU overhead. These benefits should come without significant throughput reduction compared to non-generational ZGC. The essential properties of non-generational ZGC should be preserved: Pause times should not exceed 1 millisecond, Heap sizes from a few hundred megabytes up to many terabytes should be supported, and Minimal manual configuration should be needed. As examples of the last point, there should be no need to manually configure The size of the generations, The number of threads used by the garbage collector, or For how long objects should reside in the young generation. Finally, Generational ZGC should be a better solution for most use cases than non-generational ZGC. We should eventually be able to replace the latter with the former in order to reduce long-term maintenance costs.",
        "Non-Goals": "It is not a goal to perform reference processing in the young generation.",
        "Motivation": "ZGC ( JEP 333 ) is designed for low latency and high scalability. It has been available for production use since JDK 15 ( JEP 377 ). ZGC does the majority of its work while application threads are running, pausing those threads only briefly. ZGC's pause times are consistently measured in microseconds; by contrast the pause times of the default garbage collector, G1, range from milliseconds to seconds. ZGC's low pause times are independent of heap size: Workloads can use heap sizes from a few hundred megabytes all the way up to multiple terabytes and still enjoy low pause times. For many workloads, simply using ZGC is enough to solve all latency problems related to garbage collection. This works well as long as there are sufficient resources (i.e., memory and CPU) available to ensure that ZGC can reclaim memory faster than the concurrently-running application threads consume it. However, ZGC currently stores all objects together, regardless of age, so it must collect all objects every t",
        "Description": "Enabling Generational ZGC To ensure a smooth succession, we will initially make Generational ZGC available alongside non-generational ZGC. The -XX:+UseZGC command-line option will select non-generational ZGC; to select Generational ZGC, add the -XX:+ZGenerational option: $ java -XX:+UseZGC -XX:+ZGenerational ... In a future release we intend to make Generational ZGC the default, at which point -XX:-ZGenerational will select non-generational ZGC. In an even later release we intend to remove non-generational ZGC, at which point the ZGenerational option will become obsolete. Design Generational ZGC splits the heap into two logical generations : The young generation is for recently allocated objects while the old generation is for long-lived objects. Each generation is collected independently of the other, so ZGC can focus on collecting the profitable young objects. As in non-generational ZGC, all garbage collection is done concurrently while the application is running, with application pa",
        "Alternatives": "Simpler barrier and pointer-coloring schemes The current load and store barrier implementation is non-trivial to understand. A simpler version could be easier to maintain at the cost of more expensive load and store barriers. We evaluated around ten different barrier implementations; none was as performant as the chosen shift-based load barrier. Continued investigation and analysis of this performance vs. complexity trade-off might still be worth considering. Keep using multi-mapped memory The colorless-roots scheme could be skipped by using a simpler solution that utilizes multi-mapped memory. If more metadata bits in the pointers are needed than in non-generational ZGC, then the maximum heap size would be restricted. Another approach could be to use a hybrid solution, with some bits using multi-mapped memory and other bits being removed and added by the load and store barriers.",
        "Testing": "The ZGC implementation uses distinct C++ types for colorless and colored pointers which ensure that no implicit conversion can be made between the two types. Colored pointers are restricted to the GC code and to barriers. As long as the runtime system uses HotSpot's access API and barriers to access object pointers, it will only ever see dereferenceable colorless pointers. The runtime-visible object pointer type will always contain colorless pointers. We inject extensive verification code into the different object-pointer types to quickly find when pointers are broken or barriers are missing. The standard set of tests for garbage collection algorithms will be used to demonstrate correctness.",
        "Risks and Assumptions": "Implementation complexity The barriers and colored pointers used in Generational ZGC are more complex than those in non-generational ZGC. Generational ZGC also runs two garbage collectors concurrently; these collectors are fairly independent but they do interact in a few intricate ways, adding to the complexity of the implementation. Given the extra complexity, in the long term we intend to minimize maintenance costs by fully replacing the original, non-generational version of ZGC with Generational ZGC. Generational ZGC will perform differently than non-generational ZGC We believe that Generational ZGC will be better suited than its predecessor to most use cases. Some workloads might even experience a throughput improvement with Generational ZGC due to lower resource usage. For example, when running an Apache Cassandra benchmark Generational ZGC requires a quarter of the heap size yet achieves four times the throughput compared to non-generational ZGC, while still keeping pause times u",
        "Specification": "Review Compiler Conformance Core Libraries Governing Board HotSpot IDE Tooling &amp; Support Internationalization JMX Members Networking Porters Quality Security Serviceability Vulnerability Web Projects ( overview , archive ) Amber Babylon CRaC Code Tools Coin Common VM Interface Developers' Guide Device I/O Duke Galahad Graal IcedTea JDK 8 Updates JDK 9 JDK (&#8230;, 24 , 25 , 26 ) JDK Updates JMC Jigsaw Kona Lanai Leyden Lilliput Locale Enhancement Loom Memory Model Update Metropolis Multi-Language VM Nashorn New I/O OpenJFX Panama Penrose Port: AArch32 Port: AArch64 Port: BSD Port: Haiku Port: Mac OS X Port: MIPS Port: Mobile Port: PowerPC/AIX Port: RISC-V Port: s390x SCTP Shenandoah Skara Sumatra Tsan Valhalla Verona VisualVM Wakefield Zero ZGC &#169; 2025 Oracle Corporation and/or its affiliates Terms of Use &#183; License: GPLv2 &#183; Privacy &#183; Trademarks"
      },
      "fullText": "JEP 439: Generational ZGC JEP 439: Generational ZGC Owner Stefan Karlsson Type Feature Scope JDK Status Closed&#8201;/&#8201;Delivered Release 21 Component hotspot&#8201;/&#8201;gc Discussion hotspot dash gc dash dev at openjdk dot org Effort XL Duration XL Relates to JEP 377: ZGC: A Scalable Low-Latency Garbage Collector (Production) JEP 474: ZGC: Generational Mode by Default JEP 490: ZGC: Remove the Non-Generational Mode Reviewed by Erik Helin, Erik &#214;sterlund, Vladimir Kozlov Endorsed by Vladimir Kozlov Created 2021/08/25 12:01 Updated 2024/10/07 17:28 Issue 8272979 Summary Improve application performance by extending the Z Garbage Collector ( ZGC ) to maintain separate generations for young and old objects. This will allow ZGC to collect young objects &#8212; which tend to die young &#8212; more frequently. Goals Applications running with Generational ZGC should enjoy Lower risks of allocations stalls, Lower required heap memory overhead, and Lower garbage collection CPU overhead. These benefits should come without significant throughput reduction compared to non-generational ZGC. The essential properties of non-generational ZGC should be preserved: Pause times should not exceed 1 millisecond, Heap sizes from a few hundred megabytes up to many terabytes should be supported, and Minimal manual configuration should be needed. As examples of the last point, there should be no need to manually configure The size of the generations, The number of threads used by the garbage collector, or For how long objects should reside in the young generation. Finally, Generational ZGC should be a better solution for most use cases than non-generational ZGC. We should eventually be able to replace the latter with the former in order to reduce long-term maintenance costs. Non-Goals It is not a goal to perform reference processing in the young generation. Motivation ZGC ( JEP 333 ) is designed for low latency and high scalability. It has been available for production use since JDK 15 ( JEP 377 ). ZGC does the majority of its work while application threads are running, pausing those threads only briefly. ZGC's pause times are consistently measured in microseconds; by contrast the pause times of the default garbage collector, G1, range from milliseconds to seconds. ZGC's low pause times are independent of heap size: Workloads can use heap sizes from a few hundred megabytes all the way up to multiple terabytes and still enjoy low pause times. For many workloads, simply using ZGC is enough to solve all latency problems related to garbage collection. This works well as long as there are sufficient resources (i.e., memory and CPU) available to ensure that ZGC can reclaim memory faster than the concurrently-running application threads consume it. However, ZGC currently stores all objects together, regardless of age, so it must collect all objects every time it runs. The weak generational hypothesis states that young objects tend to die young, while old objects tend "
    }
  },
  {
    "url": "https://openjdk.org/jeps/451",
    "title": "JEP 451: Prepare to Disallow the Dynamic Loading of Agents",
    "content": {
      "title": "JEP 451: Prepare to Disallow the Dynamic Loading of Agents",
      "summary": "JEP 451: Prepare to Disallow the Dynamic Loading of Agents JEP 451: Prepare to Disallow the Dynamic Loading of Agents Author Ron Pressler &amp; Alex Buckley Owner Ron Pressler Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component hotspot&#8201;/&#8201;svc Discussion jigsaw dash dev at openjdk dot org, serviceability dash dev at openjdk dot org Reviewed by Alan Bateman, Dan Heidinga Endorsed by Mark Reinhold, Serguei Spitsyn Created 2023/04/18 09:39 Updated 2023/08/21 1",
      "sections": {
        "Summary": "Issue warnings when agents are loaded dynamically into a running JVM. These warnings aim to prepare users for a future release which disallows the dynamic loading of agents by default in order to improve integrity by default . Serviceability tools that load agents at startup will not cause warnings to be issued in any release.",
        "Goals": "Prepare for a future release of the JDK that will, by default, disallow the loading of agents into a running JVM. Reassess the balance between serviceability, which involves ad-hoc changes to running code, and integrity, which assumes that running code is not arbitrarily changed. Ensure that the majority of tools &#8212; which do not need to load agents dynamically &#8212; are unaffected. Align the ability to load agents dynamically with other so-called \"superpower\" capabilities, such as deep reflection .",
        "Non-Goals": "It is not a goal to prevent agents from being loaded at JVM startup via the -javaagent or -agentlib command-line options, nor to issue warnings upon such use. It is not a goal to deprecate or remove the parts of the Attach API which load agents dynamically; it is only a goal to prepare for their use being disallowed by default. It is not a goal to change the parts of the Attach API which allow serviceability tools to connect to a running JVM for monitoring and management purposes. Tools such as jcmd and jconsole will continue to work without command line options and without warnings.",
        "Motivation": "Agents in the Java Platform An agent is a component that can alter the code of an application while the application is running. Agents were introduced by the Java Platform Profiling Architecture in JDK&#160;5 as a way for tools, notably profilers, to instrument classes. This means altering the code in a class so that it emits events to be consumed by a tool outside the application, without otherwise changing the code's behavior. Agents achieve this either by transforming classes during class loading, or by redefining classes loaded earlier. They can be written in Java code using the java.lang.instrument API (\"Java agents\"), or in native code using the JVM Tool Interface (\"JVM TI agents\"). Agents were designed with benign instrumentation in mind, where the addition of instrumentation does not affect application behavior. However, advanced developers found use cases such as Aspect-Oriented Programming that change application behavior in arbitrary ways. There is also nothing to stop an ag",
        "Description": "In JDK 21, the dynamic loading of agents is allowed but the JVM issues a warning when it occurs. For example: WARNING: A {Java,JVM TI} agent has been loaded dynamically (file:/u/bob/agent.jar) WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning WARNING: If a serviceability tool is not in use, please run with -Djdk.instrument.traceUsage for more information WARNING: Dynamic loading of agents will be disallowed by default in a future release To allow tools to dynamically load agents without warnings, users must run with the -XX:+EnableDynamicAgentLoading option on the command line. Running with -Djdk.instrument.traceUsage causes the methods of the java.lang.instrument API to print a message and a stack trace when used. This helps identify libraries that incorrectly use dynamically loaded agents instead of agents loaded at startup. Maintainers of libraries that load agents dynamically are encouraged to update their documentation",
        "Alternatives": "Warn only on the dynamic loading of native JVM TI agents by default, and restrict the capabilities of dynamically loaded Java agents by default (i.e., when the -XX:+EnableDynamicAgentLoading option is not specified) such that a warning is issued when they attempt to modify classes in named modules while allowing them to modify classes in unnamed modules without warning. This approach is more complex and does not support substantially more practical tooling agents. Moreover, it does not preclude a Java agent from employing JNI to grant itself further powers. Employ an authentication mechanism that distinguishes between a human-operated tool and a library masquerading as a tool to, by default, allow a tool to dynamically load an agent without warning but warn when a library attempts to dynamically load an agent. We have explored several approaches along these lines, but all were either complex or required special setup on the command line, which would not reduce the impact on tools that ",
        "Testing": "library might redefine JDK classes so that reflection over private fields is always permitted. To obtain these capabilities, a library can employ an agent that obtains an all-powerful Instrumentation object from the JVM and conveys it to the library. Some such libraries ensure that the application owner grants approval to alter the application by requiring the library's agent to be specified on the command line with the -javaagent option. An example of a library that did this was Quasar , an early prototype of what later became Virtual Threads (JEP 444) . Other libraries take a more dubious approach, obtaining capabilities without the approval of the application owner. They use the Attach API to silently connect to the JVMs in which they run and load agents dynamically, in effect masquerading as serviceability tools. To maintain integrity, JDK&#160;9 and later releases prevent code from connecting to the current JVM by default. (Such connections can be enabled via -Djdk.attach.allowAtt",
        "Risks and Assumptions": "We assume that most serviceability scenarios involve the use of jcmd , jconsole , debuggers, JFR, and APM tools, which do not dynamically load agents and will therefore not be affected. We assume that maintainers of libraries which dynamically load an agent will update their documentation to ask application owners to load the agent at startup with the -javaagent option, or else enable the dynamic loading of agents via the -XX:+EnableDynamicAgentLoading option. Future Work Advanced profilers that profile native code use JVM TI agents merely to gain access to internal HotSpot mechanisms that can support profiling. When profiling an application in production, they may load the agent dynamically. This use case is best addressed by expanding the capabilities of JFR to perform the task without requiring an agent at all. JFR is able to cooperate with HotSpot's JIT compiler to capture large batches of stack traces far more efficiently than anything that could be exposed through the JVM TI API ",
        "Specification": "Review Compiler Conformance Core Libraries Governing Board HotSpot IDE Tooling &amp; Support Internationalization JMX Members Networking Porters Quality Security Serviceability Vulnerability Web Projects ( overview , archive ) Amber Babylon CRaC Code Tools Coin Common VM Interface Developers' Guide Device I/O Duke Galahad Graal IcedTea JDK 8 Updates JDK 9 JDK (&#8230;, 24 , 25 , 26 ) JDK Updates JMC Jigsaw Kona Lanai Leyden Lilliput Locale Enhancement Loom Memory Model Update Metropolis Multi-Language VM Nashorn New I/O OpenJFX Panama Penrose Port: AArch32 Port: AArch64 Port: BSD Port: Haiku Port: Mac OS X Port: MIPS Port: Mobile Port: PowerPC/AIX Port: RISC-V Port: s390x SCTP Shenandoah Skara Sumatra Tsan Valhalla Verona VisualVM Wakefield Zero ZGC &#169; 2025 Oracle Corporation and/or its affiliates Terms of Use &#183; License: GPLv2 &#183; Privacy &#183; Trademarks"
      },
      "fullText": "JEP 451: Prepare to Disallow the Dynamic Loading of Agents JEP 451: Prepare to Disallow the Dynamic Loading of Agents Author Ron Pressler &amp; Alex Buckley Owner Ron Pressler Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component hotspot&#8201;/&#8201;svc Discussion jigsaw dash dev at openjdk dot org, serviceability dash dev at openjdk dot org Reviewed by Alan Bateman, Dan Heidinga Endorsed by Mark Reinhold, Serguei Spitsyn Created 2023/04/18 09:39 Updated 2023/08/21 14:44 Issue 8306275 Summary Issue warnings when agents are loaded dynamically into a running JVM. These warnings aim to prepare users for a future release which disallows the dynamic loading of agents by default in order to improve integrity by default . Serviceability tools that load agents at startup will not cause warnings to be issued in any release. Goals Prepare for a future release of the JDK that will, by default, disallow the loading of agents into a running JVM. Reassess the balance between serviceability, which involves ad-hoc changes to running code, and integrity, which assumes that running code is not arbitrarily changed. Ensure that the majority of tools &#8212; which do not need to load agents dynamically &#8212; are unaffected. Align the ability to load agents dynamically with other so-called \"superpower\" capabilities, such as deep reflection . Non-Goals It is not a goal to prevent agents from being loaded at JVM startup via the -javaagent or -agentlib command-line options, nor to issue warnings upon such use. It is not a goal to deprecate or remove the parts of the Attach API which load agents dynamically; it is only a goal to prepare for their use being disallowed by default. It is not a goal to change the parts of the Attach API which allow serviceability tools to connect to a running JVM for monitoring and management purposes. Tools such as jcmd and jconsole will continue to work without command line options and without warnings. Motivation Agents in the Java Platform An agent is a component that can alter the code of an application while the application is running. Agents were introduced by the Java Platform Profiling Architecture in JDK&#160;5 as a way for tools, notably profilers, to instrument classes. This means altering the code in a class so that it emits events to be consumed by a tool outside the application, without otherwise changing the code's behavior. Agents achieve this either by transforming classes during class loading, or by redefining classes loaded earlier. They can be written in Java code using the java.lang.instrument API (\"Java agents\"), or in native code using the JVM Tool Interface (\"JVM TI agents\"). Agents were designed with benign instrumentation in mind, where the addition of instrumentation does not affect application behavior. However, advanced developers found use cases such as Aspect-Oriented Programming that change application behavior in arbitrary ways. There is also nothing to stop an agent from alteri"
    }
  },
  {
    "url": "https://openjdk.org/jeps/441",
    "title": "JEP 441: Pattern Matching for switch",
    "content": {
      "title": "JEP 441: Pattern Matching for switch",
      "summary": "JEP 441: Pattern Matching for switch JEP 441: Pattern Matching for switch Owner Gavin Bierman Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component specification&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Relates to JEP 433: Pattern Matching for switch (Fourth Preview) Reviewed by Brian Goetz Endorsed by Brian Goetz Created 2023/01/18 14:43 Updated 2023/09/19 13:38 Issue 8300542 Summary Enhance the Java programming language with pattern matchin",
      "sections": {
        "Summary": "Enhance the Java programming language with pattern matching for switch expressions and statements. Extending pattern matching to switch allows an expression to be tested against a number of patterns, each with a specific action, so that complex data-oriented queries can be expressed concisely and safely. History This feature was originally proposed by JEP&#160;406 (JDK&#160;17) and subsequently refined by JEPs 420 (JDK&#160;18), 427 (JDK&#160;19), and 433 (JDK&#160;20). It has co-evolved with the Record Patterns feature ( JEP&#160;440 ), with which it has considerable interaction. This JEP proposes to finalize the feature with further small refinements based upon continued experience and feedback. Apart from various editorial changes, the main changes from the previous JEP are to: Remove parenthesized patterns, since they did not have sufficient value, and Allow qualified enum constants as case constants in switch expressions and statements.",
        "Goals": "Expand the expressiveness and applicability of switch expressions and statements by allowing patterns to appear in case labels. Allow the historical null-hostility of switch to be relaxed when desired. Increase the safety of switch statements by requiring that pattern switch statements cover all possible input values. Ensure that all existing switch expressions and statements continue to compile with no changes and execute with identical semantics.",
        "Motivation": "In Java 16, JEP&#160;394 extended the instanceof operator to take a type pattern and perform pattern matching . This modest extension allows the familiar instanceof-and-cast idiom to be simplified, making it both more concise and less error-prone: // Prior to Java 16 if (obj instanceof String) { String s = (String)obj; ... use s ... } // As of Java 16 if (obj instanceof String s) { ... use s ... } In the new code, obj matches the type pattern String s if, at run time, the value of obj is an instance of String . If the pattern matches then the instanceof expression is true and the pattern variable s is initialized to the value of obj cast to String , which can then be used in the contained block. We often want to compare a variable such as obj against multiple",
        "Description": "We enhance switch statements and expressions in four ways: Improve enum constant case labels, Extend case labels to include patterns and null in addition to constants, Broaden the range of types permitted for the selector expressions of both switch statements and switch expressions (along with the required richer analysis of exhaustiveness of switch blocks), and Allow optional when clauses to follow case labels. Improved enum constant case labels It has long been a requirement that, when switching over an enum type, the only valid case constants were enum constants. But this is a strong requirement that becomes burdensome with the new, richer forms of switch. To maintain compatibility with existing Java code, when switching over an enum type a case constant can still use the simple name of a constant of the enum type being switched over. For new code, we extend the treatment of enums. First, we allow qualified names of enum constants to appear as case constants. These qualified names c",
        "Alternatives": ". Java supports multi-way comparisons with switch statements and, since Java&#160;14, switch expressions ( JEP&#160;361 ), but unfortunately switch is very limited. We can only switch on values of a few types &#8212; integral primitive types (excluding long ), their corresponding boxed forms, enum types, and String &#8212; and we can only test for exact equality against constants. We might like to use patterns to test the same variable against a number of possibilities, taking a specific action on each, but since the existing switch does not support that we end up with a chain of if...else tests such as: // Prior to Java 21 static String formatter(Object obj) { String formatted = \"unknown\"; if (obj instanceof Integer i) { formatted = String.format(\"int %d\", i); } else if (obj instanceof Long l) { formatted = String.format(\"long %d\", l); } else if (obj instanceof Double d) { formatted = String.format(\"double %f\", d); } else if (obj instanceof String s) { formatted = String.format(\"Strin",
        "Testing": "for null must be done outside of the switch : // Prior to Java 21 static void testFooBarOld(String s) { if (s == null) { System.out.println(\"Oops!\"); return; } switch (s) { case \"Foo\", \"Bar\" -&gt; System.out.println(\"Great\"); default -&gt; System.out.println(\"Ok\"); } } This was reasonable when switch supported only a few reference types. However, if switch allows a selector expression of any reference type, and case labels can have type patterns, then the standalone null test feels like an arbitrary distinction which invites needless boilerplate and opportunities for error. It would be better to integrate the null test into the switch by allowing a new null case label: // As of Java 21 static void testFooBarNew(String s) { switch (s) { case null -&gt; System.out.println(\"Oops\"); case \"Foo\", \"Bar\" -&gt; System.out.println(\"Great\"); default -&gt; System.out.println(\"Ok\"); } } The behavior of the switch when the value of the selector expression is null is always determined by its case lab",
        "Dependencies": "This JEP builds on Pattern Matching for instanceof ( JEP 394 ), delivered in JDK&#160;16, and also the enhancements offered by Switch Expressions ( JEP&#160;361 ). It has co-evolved with Record Patterns ( JEP&#160;440 ). Installing Contributing Sponsoring Developers' Guide Vulnerabilities JDK GA/EA Builds Mailing lists Wiki &#183; IRC Mastodon Bluesky Bylaws &#183; Census Legal Workshop JEP Process Source code GitHub Mercurial Tools Git jtreg harness Groups (overview) Adoption Build Client Libraries Compatibility &amp;",
        "Specification": "&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Relates to JEP 433: Pattern Matching for switch (Fourth Preview) Reviewed by Brian Goetz Endorsed by Brian Goetz Created 2023/01/18 14:43 Updated 2023/09/19 13:38 Issue 8300542"
      },
      "fullText": "JEP 441: Pattern Matching for switch JEP 441: Pattern Matching for switch Owner Gavin Bierman Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component specification&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Relates to JEP 433: Pattern Matching for switch (Fourth Preview) Reviewed by Brian Goetz Endorsed by Brian Goetz Created 2023/01/18 14:43 Updated 2023/09/19 13:38 Issue 8300542 Summary Enhance the Java programming language with pattern matching for switch expressions and statements. Extending pattern matching to switch allows an expression to be tested against a number of patterns, each with a specific action, so that complex data-oriented queries can be expressed concisely and safely. History This feature was originally proposed by JEP&#160;406 (JDK&#160;17) and subsequently refined by JEPs 420 (JDK&#160;18), 427 (JDK&#160;19), and 433 (JDK&#160;20). It has co-evolved with the Record Patterns feature ( JEP&#160;440 ), with which it has considerable interaction. This JEP proposes to finalize the feature with further small refinements based upon continued experience and feedback. Apart from various editorial changes, the main changes from the previous JEP are to: Remove parenthesized patterns, since they did not have sufficient value, and Allow qualified enum constants as case constants in switch expressions and statements. Goals Expand the expressiveness and applicability of switch expressions and statements by allowing patterns to appear in case labels. Allow the historical null-hostility of switch to be relaxed when desired. Increase the safety of switch statements by requiring that pattern switch statements cover all possible input values. Ensure that all existing switch expressions and statements continue to compile with no changes and execute with identical semantics. Motivation In Java 16, JEP&#160;394 extended the instanceof operator to take a type pattern and perform pattern matching . This modest extension allows the familiar instanceof-and-cast idiom to be simplified, making it both more concise and less error-prone: // Prior to Java 16 if (obj instanceof String) { String s = (String)obj; ... use s ... } // As of Java 16 if (obj instanceof String s) { ... use s ... } In the new code, obj matches the type pattern String s if, at run time, the value of obj is an instance of String . If the pattern matches then the instanceof expression is true and the pattern variable s is initialized to the value of obj cast to String , which can then be used in the contained block. We often want to compare a variable such as obj against multiple alternatives. Java supports multi-way comparisons with switch statements and, since Java&#160;14, switch expressions ( JEP&#160;361 ), but unfortunately switch is very limited. We can only switch on values of a few types &#8212; integral primitive types (excluding long ), their corresponding boxed forms, enum types, and String &#8212; and we can only test for "
    }
  },
  {
    "url": "https://openjdk.org/jeps/440",
    "title": "JEP 440: Record Patterns",
    "content": {
      "title": "JEP 440: Record Patterns",
      "summary": "JEP 440: Record Patterns JEP 440: Record Patterns Owner Gavin Bierman Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component specification&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Relates to JEP 432: Record Patterns (Second Preview) Reviewed by Brian Goetz Endorsed by Brian Goetz Created 2023/01/18 14:38 Updated 2023/08/28 16:51 Issue 8300541 Summary Enhance the Java programming language with record patterns to deconstruct record values. Recor",
      "sections": {
        "Summary": "Enhance the Java programming language with record patterns to deconstruct record values. Record patterns and type patterns can be nested to enable a powerful, declarative, and composable form of data navigation and processing. History Record patterns were proposed as a preview feature by JEP&#160;405 and delivered in JDK&#160;19 , and previewed a second time by JEP&#160;432 and delivered in JDK&#160;20 . This feature has co-evolved with Pattern Matching for switch ( JEP&#160;441 ), with which it has considerable interaction. This JEP proposes to finalize the feature with further refinements based upon continued experience and feedback. Apart from some minor editorial changes, the main change since the second preview is to remove support for record patterns appearing in the header of an enhanced for statement. This feature may be re-proposed in a future JEP.",
        "Goals": "Extend pattern matching to destructure instances of record classes, enabling more sophisticated data queries. Add nested patterns, enabling more composable data queries.",
        "Motivation": "In Java 16, JEP&#160;394 extended the instanceof operator to take a type pattern and perform pattern matching . This modest extension allows the familiar instanceof-and-cast idiom to be simplified, making it both more concise and less error-prone: // Prior to Java 16 if (obj instanceof String) { String s = (String)obj; ... use s ... } // As of Java 16 if (obj instanceof String s) { ... use s ... } In the new code, obj matches the type pattern String s if, at run time, the value of obj is an instance of String . If the pattern matches then the instanceof expression is true and the pattern variable s is initialized to the value of obj cast to String , which can then be used in the contained block. Type patterns remove many occurrences of casting at a stroke. However, they are only the first step towards a more declarative, data-focused style of programming. As Java supports new and more expressive ways of modeling data, pattern matching can streamline the use of such data by enabling dev",
        "Description": "We extend the Java programming language with nestable record patterns. The grammar for patterns becomes: Pattern: TypePattern RecordPattern TypePattern: LocalVariableDeclaration RecordPattern: ReferenceType ( [ PatternList ] ) PatternList : Pattern { , Pattern } Record patterns A record pattern consists of a record class type and a (possibly empty) pattern list which is used to match against the corresponding record component values. For example, given the declaration record Point(int i, int j) {} a value v matches the record pattern Point(int i, int j) if it is an instance of the record type Point ; if so, the pattern variable i is initialized with the result of invoking the accessor method corresponding to i on the value v , and the pattern variable j is initialized to the result of invoking the accessor method corresponding to j on the value v . (The names of the pattern variables do not need to be the same as the names of the record components; i.e., the record pattern Point(int x,",
        "Dependencies": "This JEP builds on Pattern Matching for instanceof ( JEP 394 ), delivered in JDK&#160;16. It has co-evolved with Pattern Matching for switch ( JEP&#160;441 ). Installing Contributing Sponsoring Developers' Guide Vulnerabilities JDK GA/EA Builds Mailing lists Wiki &#183; IRC Mastodon Bluesky Bylaws &#183; Census Legal Workshop JEP Process Source code GitHub Mercurial Tools Git jtreg harness Groups (overview) Adoption Build Client Libraries Compatibility &amp;",
        "Specification": "&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Relates to JEP 432: Record Patterns (Second Preview) Reviewed by Brian Goetz Endorsed by Brian Goetz Created 2023/01/18 14:38 Updated 2023/08/28 16:51 Issue 8300541"
      },
      "fullText": "JEP 440: Record Patterns JEP 440: Record Patterns Owner Gavin Bierman Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component specification&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Relates to JEP 432: Record Patterns (Second Preview) Reviewed by Brian Goetz Endorsed by Brian Goetz Created 2023/01/18 14:38 Updated 2023/08/28 16:51 Issue 8300541 Summary Enhance the Java programming language with record patterns to deconstruct record values. Record patterns and type patterns can be nested to enable a powerful, declarative, and composable form of data navigation and processing. History Record patterns were proposed as a preview feature by JEP&#160;405 and delivered in JDK&#160;19 , and previewed a second time by JEP&#160;432 and delivered in JDK&#160;20 . This feature has co-evolved with Pattern Matching for switch ( JEP&#160;441 ), with which it has considerable interaction. This JEP proposes to finalize the feature with further refinements based upon continued experience and feedback. Apart from some minor editorial changes, the main change since the second preview is to remove support for record patterns appearing in the header of an enhanced for statement. This feature may be re-proposed in a future JEP. Goals Extend pattern matching to destructure instances of record classes, enabling more sophisticated data queries. Add nested patterns, enabling more composable data queries. Motivation In Java 16, JEP&#160;394 extended the instanceof operator to take a type pattern and perform pattern matching . This modest extension allows the familiar instanceof-and-cast idiom to be simplified, making it both more concise and less error-prone: // Prior to Java 16 if (obj instanceof String) { String s = (String)obj; ... use s ... } // As of Java 16 if (obj instanceof String s) { ... use s ... } In the new code, obj matches the type pattern String s if, at run time, the value of obj is an instance of String . If the pattern matches then the instanceof expression is true and the pattern variable s is initialized to the value of obj cast to String , which can then be used in the contained block. Type patterns remove many occurrences of casting at a stroke. However, they are only the first step towards a more declarative, data-focused style of programming. As Java supports new and more expressive ways of modeling data, pattern matching can streamline the use of such data by enabling developers to express the semantic intent of their models. Pattern matching and records Records ( JEP 395 ) are transparent carriers for data. Code that receives an instance of a record class will typically extract the data, known as the components , using the built-in component accessor methods. For example, we can use a type pattern to test whether a value is an instance of the record class Point and, if so, extract the x and y components from the value: // As of Java 16 record Point(int x, int y) {} static void printSum(Object obj)"
    }
  },
  {
    "url": "https://openjdk.org/jeps/444",
    "title": "JEP 444: Virtual Threads",
    "content": {
      "title": "JEP 444: Virtual Threads",
      "summary": "JEP 444: Virtual Threads JEP 444: Virtual Threads Author Ron Pressler &amp; Alan Bateman Owner Alan Bateman Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component core-libs Discussion loom dash dev at openjdk dot org Relates to JEP 436: Virtual Threads (Second Preview) Reviewed by Alex Buckley Endorsed by Brian Goetz Created 2023/03/06 18:00 Updated 2024/07/10 14:29 Issue 8303683 Summary Introduce virtual threads to the Java Platform. Virtual threads are lightweight thr",
      "sections": {
        "Summary": "Introduce virtual threads to the Java Platform. Virtual threads are lightweight threads that dramatically reduce the effort of writing, maintaining, and observing high-throughput concurrent applications. History Virtual threads were proposed as a preview feature by JEP 425 and delivered in JDK&#160;19 . To allow time for feedback and to get more experience, they were proposed as a preview feature again by JEP&#160;436 and delivered in JDK&#160;20 . This JEP proposes to finalize virtual threads in JDK&#160;21 with the following changes from JDK&#160;20, informed by developer feedback: Virtual threads now always support thread-local variables . It is no longer possible, as it was in the preview releases, to create virtual threads that cannot have thread-local variables. Guaranteed support for thread-local variables ensures that many more existing libraries can be used unchanged with virtual threads, and helps with the migration of task-oriented code to use virtual threads. Virtual thread",
        "Goals": "Enable server applications written in the simple thread-per-request style to scale with near-optimal hardware utilization. Enable existing code that uses the java.lang.Thread API to adopt virtual threads with minimal change. Enable easy troubleshooting, debugging, and profiling of virtual threads with existing JDK tools.",
        "Non-Goals": "It is not a goal to remove the traditional implementation of threads, or to silently migrate existing applications to use virtual threads. It is not a goal to change the basic concurrency model of Java. It is not a goal to offer a new data parallelism construct in either the Java language or the Java libraries. The Stream API remains the preferred way to process large data sets in parallel.",
        "Motivation": "Java developers have relied on threads as the building block of concurrent server applications for nearly three decades. Every statement in every method is executed inside a thread and, since Java is multithreaded, multiple threads of execution happen at once. The thread is Java's unit of concurrency: a piece of sequential code that runs concurrently with &#8212; and largely independently of &#8212; other such units. Each thread provides a stack to store local variables and coordinate method calls, as well as context when things go wrong: Exceptions are thrown and caught by methods in the same thread, so developers can use a thread's stack trace to find out what happened. Threads are also a central concept for tools: Debuggers step through the statements in a thread's methods, and profilers visualize the behavior of multiple threads to help understand their performance. The thread-per-request style Server applications generally handle concurrent user requests that are independent of ea",
        "Description": "Today, every instance of java.lang.Thread in the JDK is a platform thread . A platform thread runs Java code on an underlying OS thread and captures the OS thread for the code's entire lifetime. The number of platform threads is limited to the number of OS threads. A virtual thread is an instance of java.lang.Thread that runs Java code on an underlying OS thread but does not capture the OS thread for the code's entire lifetime. This means that many virtual threads can run their Java code on the same OS thread, effectively sharing it. While a platform thread monopolizes a precious OS thread, a virtual thread does not. The number of virtual threads can be much larger than the number of OS threads. Virtual threads are a lightweight implementation of threads that is provided by the JDK rather than the OS. They are a form of user-mode threads , which have been successful in other multithreaded languages (e.g., goroutines in Go and processes in Erlang). User-mode threads even featured as so-",
        "Alternatives": "Continue to rely on asynchronous APIs. Asynchronous APIs are difficult to integrate with synchronous APIs, create a split world of two representations of the same I/O operations, and provide no unified concept of a sequence of operations that can be used by the platform as context for troubleshooting, monitoring, debugging, and profiling. Add syntactic stackless coroutines (i.e., async/await ) to the Java language. These are easier to implement than user-mode threads and would provide a unifying construct representing the context of a sequence of operations. That construct would be new, however, and separate from threads, similar to them in many respects yet different in some nuanced ways. It would split the world between APIs designed for threads and APIs designed for coroutines, and would require the new thread-like construct to be introduced into all layers of the platform and its tooling. This would take longer for the ecosystem to adopt, and would not be as elegant and harmonious ",
        "Testing": "Existing tests will ensure that the changes we propose here do not cause unexpected regressions in the multitude of configurations and execution modes in which they are run. We will extend the jtreg test harness to allow existing tests to be run in the context of a virtual thread. This will avoid needing two versions of many tests. New tests will exercise all new and revised APIs, and all areas changed to support virtual threads. New stress tests will target areas that are critical to reliability and performance. New microbenchmarks will target performance-critical areas. We will use a number of existing servers, including Helidon and Jetty , for larger-scale",
        "Risks and Assumptions": "The primary risks of this proposal are ones of compatibility due to changes in existing APIs and their implementations: The revisions to the internal (and undocumented) locking protocol used in the java.io.BufferedInputStream , BufferedOutputStream , BufferedReader , BufferedWriter , PrintStream , and PrintWriter classes may impact code that assumes that I/O methods synchronize on the stream upon which they are invoked. These changes do not impact code that extends these classes and assumes locking by the superclass, nor do they impact code that extends java.io.Reader or java.io.Writer and uses the lock object exposed by those APIs. A few source and binary incompatible changes may impact code that extends java.lang.Thread : Thread defines several new methods. If code in an existing source file extends Thread and a method in the subclass conflicts with any of the new Thread methods then the file will not compile without change. Thread.Builder is a new nested interface. If code in an exi",
        "Dependencies": "JEP 416 (Reimplement Core Reflection with Method Handles) in JDK&#160;18 removed the VM-native reflection implementation. This allows virtual threads to park gracefully when methods are invoked reflectively. JEP 353 (Reimplement the Legacy Socket API) in JDK&#160;13, and JEP 373 (Reimplement the Legacy DatagramSocket API) in JDK&#160;15, replaced the implementations of java.net.Socket , ServerSocket , and DatagramSocket with new implementations designed for use with virtual threads. JEP 418 (Internet-Address Resolution SPI) in JDK&#160;18 defined a service-provider interface for host name and address lookup. This will allow third-party libraries to implement alternative java.net.InetAddress resolvers that do not pin threads during host lookup. Installing Contributing Sponsoring Developers' Guide Vulnerabilities JDK GA/EA Builds Mailing lists Wiki &#183; IRC Mastodon Bluesky Bylaws &#183; Census Legal Workshop JEP Process Source code GitHub Mercurial Tools Git jtreg harness Groups (over",
        "Specification": "is otherwise unchanged. Debugging The debugging architecture consists of three interfaces: the JVM Tool Interface (JVM TI), the Java Debug Wire Protocol (JDWP), and the Java Debug Interface (JDI). All three interfaces now support virtual threads. The updates to JVM TI are: Most functions that are called with a jthread (i.e., a JNI reference to a Thread object) can be called with a reference to a virtual thread. A small number of functions, namely AgentStartFunction , PopFrame , ForceEarlyReturn* , StopThread , and GetThreadCpuTime , are not supported or are optionally supported on virtual threads. The SetLocal* functions are limited to setting local variables in the top-most frames of virtual threads that are suspended at a breakpoint or single step event. The GetAllThreads and GetAllStackTraces functions are now specified to return all platform threads rather than all threads. All events, with the exception of those posted during early VM startup or during heap iteration, can have eve"
      },
      "fullText": "JEP 444: Virtual Threads JEP 444: Virtual Threads Author Ron Pressler &amp; Alan Bateman Owner Alan Bateman Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component core-libs Discussion loom dash dev at openjdk dot org Relates to JEP 436: Virtual Threads (Second Preview) Reviewed by Alex Buckley Endorsed by Brian Goetz Created 2023/03/06 18:00 Updated 2024/07/10 14:29 Issue 8303683 Summary Introduce virtual threads to the Java Platform. Virtual threads are lightweight threads that dramatically reduce the effort of writing, maintaining, and observing high-throughput concurrent applications. History Virtual threads were proposed as a preview feature by JEP 425 and delivered in JDK&#160;19 . To allow time for feedback and to get more experience, they were proposed as a preview feature again by JEP&#160;436 and delivered in JDK&#160;20 . This JEP proposes to finalize virtual threads in JDK&#160;21 with the following changes from JDK&#160;20, informed by developer feedback: Virtual threads now always support thread-local variables . It is no longer possible, as it was in the preview releases, to create virtual threads that cannot have thread-local variables. Guaranteed support for thread-local variables ensures that many more existing libraries can be used unchanged with virtual threads, and helps with the migration of task-oriented code to use virtual threads. Virtual threads created directly with the Thread.Builder API (as opposed to those created through Executors.newVirtualThreadPerTaskExecutor() ) are now also, by default, monitored throughout their lifetime and observable via the new thread dump described in the Observing virtual threads section. Goals Enable server applications written in the simple thread-per-request style to scale with near-optimal hardware utilization. Enable existing code that uses the java.lang.Thread API to adopt virtual threads with minimal change. Enable easy troubleshooting, debugging, and profiling of virtual threads with existing JDK tools. Non-Goals It is not a goal to remove the traditional implementation of threads, or to silently migrate existing applications to use virtual threads. It is not a goal to change the basic concurrency model of Java. It is not a goal to offer a new data parallelism construct in either the Java language or the Java libraries. The Stream API remains the preferred way to process large data sets in parallel. Motivation Java developers have relied on threads as the building block of concurrent server applications for nearly three decades. Every statement in every method is executed inside a thread and, since Java is multithreaded, multiple threads of execution happen at once. The thread is Java's unit of concurrency: a piece of sequential code that runs concurrently with &#8212; and largely independently of &#8212; other such units. Each thread provides a stack to store local variables and coordinate method calls, as well as context when things go wrong: Exceptions "
    }
  },
  {
    "url": "https://openjdk.org/jeps/431",
    "title": "JEP 431: Sequenced Collections",
    "content": {
      "title": "JEP 431: Sequenced Collections",
      "summary": "JEP 431: Sequenced Collections JEP 431: Sequenced Collections Owner Stuart Marks Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component core-libs&#8201;/&#8201;java.util:collections Discussion core dash libs dash dev at openjdk dot org Reviewed by Brian Goetz Endorsed by Brian Goetz Created 2022/01/27 22:13 Updated 2023/10/23 17:55 Issue 8280836 Summary Introduce new interfaces to represent collections with a defined encounter order. Each such collection has a well-defi",
      "sections": {
        "Summary": "Introduce new interfaces to represent collections with a defined encounter order. Each such collection has a well-defined first element, second element, and so forth, up to the last element. It also provides uniform APIs for accessing its first and last elements, and for processing its elements in reverse order. \"Life can only be understood backwards; but it must be lived forwards.\" &#8212; Kierkegaard",
        "Motivation": "Java&#8217;s collections framework lacks a collection type that represents a sequence of elements with a defined encounter order. It also lacks a uniform set of operations that apply across such collections. These gaps have been a repeated source of problems and complaints. For example, List and Deque both define an encounter order but their common supertype is Collection , which does not. Similarly, Set does not define an encounter order, and subtypes such as HashSet do not define one, but subtypes such as SortedSet and LinkedHashSet do. Support for encounter order is thus spread across the type hierarchy, making it difficult to express certain useful concepts in APIs. Neither Collection nor List can describe a parameter or return value that has an encounter order. Collection is too general, relegating such constraints to the prose",
        "Description": "We define new interfaces for sequenced collections, sequenced sets, and sequenced maps, and then retrofit them into the existing collections type hierarchy. All of the new methods declared in these interfaces have default implementations. Sequenced collections A sequenced collection is a Collection whose elements have a defined encounter order. (The word \"sequenced\" as used here is the past participle of the verb to sequence , meaning \"to arrange elements in a particular order.\") A sequenced collection has first and last elements, and the elements between them have successors and predecessors. A sequenced collection supports common operations at either end, and it supports processing the elements from first to last and from last to first (i.e., forward and reverse). interface SequencedCollection&lt;E&gt; extends Collection&lt;E&gt; { // new method SequencedCollection&lt;E&gt; reversed(); // methods promoted from Deque void addFirst(E); void addLast(E); E getFirst(); E getLast(); E remo",
        "Alternatives": "Types An alternative to adding new types would be to repurpose the List interface as a general sequenced collection type. Indeed List is sequenced, but it also supports element access by integer index. Many sequenced data structures do not naturally support indexing and would thus be required to support it iteratively. This would result in indexed access having O(n) performance instead of the expected O(1), perpetuating the mistake of LinkedList . Deque seems promising as a general sequence type, since it already supports the right set of operations. However, it is cluttered with other operations, including a family of null-returning operations (offer, peek, and poll), stack operations (push and pop), and operations inherited from Queue . These operations are sensible for a queue but less so for other collections. If Deque were repurposed as a general sequence type then List would also be a Queue and would support stack operations, resulting in a cluttered and confusing API. Naming The",
        "Testing": "We will add a comprehensive set of tests to the JDK's regression test suite.",
        "Risks and Assumptions": "Introducing new methods high in the inheritance hierarchy runs the risk of clashes over obvious method names such as reversed() and getFirst() . Of particular concern are the covariant overrides of the reversed() method on List and Deque . These are source and binary incompatible with existing collections that implement both List and Deque . There are two examples of such collections in the JDK: LinkedList and an internal class sun.awt.util.IdentityLinkedList . The LinkedList class was handled by introducing a new reversed() covariant override on LinkedList itself. The internal IdentityLinkedList class was removed as it was no longer necessary. An earlier version of the proposal introduced covariant overrides for the keySet() , values() , and entrySet() methods of the SequencedMap interface. After some analysis it was determined that this approach introduced too great a risk of incompatibilities; essentially, it invalidates any existing subclasses. An alternative approach was selected,",
        "Specification": ", possibly leading to hard-to-debug errors. List is too specific, excluding SortedSet and LinkedHashSet . A related problem is that view collections are often forced to downgrade to weaker semantics. Wrapping a LinkedHashSet with Collections::unmodifiableSet yields a Set , discarding the information about encounter order. Without interfaces to define them, operations related to encounter order are either inconsistent or missing. While many implementations support getting the first or last element, each collection defines its own way, and some are not obvious or are missing entirely: First element Last element List list.get(0) list.get(list.size() - 1) Deque deque.getFirst() deque.getLast() SortedSet sortedSet.first() sortedSet.last() LinkedHashSet linkedHashSet.iterator().next() // missing Some of these are unnecessarily cumbersome, such as getting the last element of a List . Some are not even possible without heroics: The only way to get the last element of a LinkedHashSet is to iter"
      },
      "fullText": "JEP 431: Sequenced Collections JEP 431: Sequenced Collections Owner Stuart Marks Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component core-libs&#8201;/&#8201;java.util:collections Discussion core dash libs dash dev at openjdk dot org Reviewed by Brian Goetz Endorsed by Brian Goetz Created 2022/01/27 22:13 Updated 2023/10/23 17:55 Issue 8280836 Summary Introduce new interfaces to represent collections with a defined encounter order. Each such collection has a well-defined first element, second element, and so forth, up to the last element. It also provides uniform APIs for accessing its first and last elements, and for processing its elements in reverse order. \"Life can only be understood backwards; but it must be lived forwards.\" &#8212; Kierkegaard Motivation Java&#8217;s collections framework lacks a collection type that represents a sequence of elements with a defined encounter order. It also lacks a uniform set of operations that apply across such collections. These gaps have been a repeated source of problems and complaints. For example, List and Deque both define an encounter order but their common supertype is Collection , which does not. Similarly, Set does not define an encounter order, and subtypes such as HashSet do not define one, but subtypes such as SortedSet and LinkedHashSet do. Support for encounter order is thus spread across the type hierarchy, making it difficult to express certain useful concepts in APIs. Neither Collection nor List can describe a parameter or return value that has an encounter order. Collection is too general, relegating such constraints to the prose specification, possibly leading to hard-to-debug errors. List is too specific, excluding SortedSet and LinkedHashSet . A related problem is that view collections are often forced to downgrade to weaker semantics. Wrapping a LinkedHashSet with Collections::unmodifiableSet yields a Set , discarding the information about encounter order. Without interfaces to define them, operations related to encounter order are either inconsistent or missing. While many implementations support getting the first or last element, each collection defines its own way, and some are not obvious or are missing entirely: First element Last element List list.get(0) list.get(list.size() - 1) Deque deque.getFirst() deque.getLast() SortedSet sortedSet.first() sortedSet.last() LinkedHashSet linkedHashSet.iterator().next() // missing Some of these are unnecessarily cumbersome, such as getting the last element of a List . Some are not even possible without heroics: The only way to get the last element of a LinkedHashSet is to iterate the entire set. Similarly, iterating the elements of a collection from first to last is straightforward and consistent, but iterating in reverse order is neither. All of these collections can be iterated forward with an Iterator , the enhanced for loop, a stream() , or toArray() . Iterating in reverse is different in every case. Navigabl"
    }
  },
  {
    "url": "https://openjdk.org/jeps/452",
    "title": "JEP 452: Key Encapsulation Mechanism API",
    "content": {
      "title": "JEP 452: Key Encapsulation Mechanism API",
      "summary": "JEP 452: Key Encapsulation Mechanism API JEP 452: Key Encapsulation Mechanism API Owner Weijun Wang Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component security-libs&#8201;/&#8201;javax.crypto Discussion security dash dev at openjdk dot org Effort M Duration M Reviewed by Alan Bateman, Sean Mullan Endorsed by Sean Mullan Created 2023/01/25 03:48 Updated 2024/04/23 15:08 Issue 8301034 Summary Introduce an API for key encapsulation mechanisms (KEMs), an encryption tech",
      "sections": {
        "Summary": "Introduce an API for key encapsulation mechanisms (KEMs), an encryption technique for securing symmetric keys using public key cryptography.",
        "Goals": "Enable applications to use KEM algorithms such as the RSA Key Encapsulation Mechanism (RSA-KEM), the Elliptic Curve Integrated Encryption Scheme (ECIES), and candidate KEM algorithms for the National Institute of Standards and Technology (NIST) Post-Quantum Cryptography standardization process. Enable the use of KEMs in higher level protocols such as Transport Level Security (TLS) and in cryptographic schemes such as Hybrid Public Key Encryption (HPKE, RFC 9180 ). Allow security providers to implement KEM algorithms in either Java code or native code. Include an implementation of the Diffie-Hellman KEM (DHKEM) defined in&#160; &#167;4.1 of RFC 9180 .",
        "Non-Goals": "It is not a goal to include key pair generation in the KEM API. The existing KeyPairGenerator API is sufficient. It is not a goal to support the ISO 18033-2 defined encryption option for the encapsulate function. It is not a goal to support authenticated encapsulation and decapsulation functions as defined by RFC 9180.",
        "Motivation": "Key encapsulation is a modern cryptographic technique that secures symmetric keys using asymmetric or public key cryptography. The traditional technique for doing so is to encrypt a randomly generated symmetric key with a public key, but that requires padding and can be difficult to prove secure. A key encapsulation mechanism (KEM) instead uses properties of the public key to derive a related symmetric key, which requires no padding. The concept of a KEM was introduced by Crammer and Shoup in &#167;7.1 of Design and Analysis of Practical Public-Key Encryption Schemes Secure against Adaptive Chosen Ciphertext Attack . Shoup later proposed it as an ISO standard in &#167;3.1 of A Proposal for an ISO Standard for Public Key Encryption . It was accepted as ISO 18033-2 and published in May 2006. KEMs are a building block of Hybrid Public Key Encryption (HPKE) . The NIST Post-Quantum Cryptography (PQC) standardization process explicitly calls for KEMs and digital signature algorithms to be ev",
        "Description": "A KEM consists of three functions: A key pair generation function that returns a key pair containing a public key and a private key. A key encapsulation function , called by the sender, that takes the receiver's public key and an encryption option; it returns a secret key K and a key encapsulation message (called ciphertext in ISO 18033-2). The sender sends the key encapsulation message to the receiver. A key decapsulation function , called by the receiver, that takes the receiver's private key and the received key encapsulation message; it returns the secret key K . The key pair generation function is covered by the existing KeyPairGenerator API . We define a new class, KEM , for the encapsulation and decapsulation functions: package javax.crypto; public class DecapsulateException extends GeneralSecurityException; public final class KEM { public static KEM getInstance(String alg) throws NoSuchAlgorithmException; public static KEM getInstance(String alg, Provider p) throws NoSuchAlgori",
        "Alternatives": "Use existing APIs We considered using the existing KeyGenerator , KeyAgreement , and Cipher APIs to represent KEMs, but each of them has significant issues. Either they don't support the required feature set, or the API does not match the KEM functions. A KeyGenerator is able to generate a SecretKey , but not the key encapsulation message at the same time. As a workaround, we could potentially encode both the shared secret and the key encapsulation message as the encoded form of the SecretKey . However, this only works when the shared secret is extractable and this is not always true, as discussed above. For keys that can be extracted, it still requires the application to extract the secret and the key encapsulation message from the encoded form of the SecretKey , which is complex and error-prone. Alternatively, we could store the key encapsulation message inside the SecretKey as a separate field. However, that would require a new SecretKey subclass that has a public method to retrieve",
        "Testing": "We will add conformance tests on input, output, and exceptions, and the DHKEM known-answer tests from RFC 9180 . Installing Contributing Sponsoring Developers' Guide Vulnerabilities JDK GA/EA Builds Mailing lists Wiki &#183; IRC Mastodon Bluesky Bylaws &#183; Census Legal Workshop JEP Process Source code GitHub Mercurial Tools Git jtreg harness Groups (overview) Adoption Build Client Libraries Compatibility &amp;",
        "Specification": "Review Compiler Conformance Core Libraries Governing Board HotSpot IDE Tooling &amp; Support Internationalization JMX Members Networking Porters Quality Security Serviceability Vulnerability Web Projects ( overview , archive ) Amber Babylon CRaC Code Tools Coin Common VM Interface Developers' Guide Device I/O Duke Galahad Graal IcedTea JDK 8 Updates JDK 9 JDK (&#8230;, 24 , 25 , 26 ) JDK Updates JMC Jigsaw Kona Lanai Leyden Lilliput Locale Enhancement Loom Memory Model Update Metropolis Multi-Language VM Nashorn New I/O OpenJFX Panama Penrose Port: AArch32 Port: AArch64 Port: BSD Port: Haiku Port: Mac OS X Port: MIPS Port: Mobile Port: PowerPC/AIX Port: RISC-V Port: s390x SCTP Shenandoah Skara Sumatra Tsan Valhalla Verona VisualVM Wakefield Zero ZGC &#169; 2025 Oracle Corporation and/or its affiliates Terms of Use &#183; License: GPLv2 &#183; Privacy &#183; Trademarks"
      },
      "fullText": "JEP 452: Key Encapsulation Mechanism API JEP 452: Key Encapsulation Mechanism API Owner Weijun Wang Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component security-libs&#8201;/&#8201;javax.crypto Discussion security dash dev at openjdk dot org Effort M Duration M Reviewed by Alan Bateman, Sean Mullan Endorsed by Sean Mullan Created 2023/01/25 03:48 Updated 2024/04/23 15:08 Issue 8301034 Summary Introduce an API for key encapsulation mechanisms (KEMs), an encryption technique for securing symmetric keys using public key cryptography. Goals Enable applications to use KEM algorithms such as the RSA Key Encapsulation Mechanism (RSA-KEM), the Elliptic Curve Integrated Encryption Scheme (ECIES), and candidate KEM algorithms for the National Institute of Standards and Technology (NIST) Post-Quantum Cryptography standardization process. Enable the use of KEMs in higher level protocols such as Transport Level Security (TLS) and in cryptographic schemes such as Hybrid Public Key Encryption (HPKE, RFC 9180 ). Allow security providers to implement KEM algorithms in either Java code or native code. Include an implementation of the Diffie-Hellman KEM (DHKEM) defined in&#160; &#167;4.1 of RFC 9180 . Non-Goals It is not a goal to include key pair generation in the KEM API. The existing KeyPairGenerator API is sufficient. It is not a goal to support the ISO 18033-2 defined encryption option for the encapsulate function. It is not a goal to support authenticated encapsulation and decapsulation functions as defined by RFC 9180. Motivation Key encapsulation is a modern cryptographic technique that secures symmetric keys using asymmetric or public key cryptography. The traditional technique for doing so is to encrypt a randomly generated symmetric key with a public key, but that requires padding and can be difficult to prove secure. A key encapsulation mechanism (KEM) instead uses properties of the public key to derive a related symmetric key, which requires no padding. The concept of a KEM was introduced by Crammer and Shoup in &#167;7.1 of Design and Analysis of Practical Public-Key Encryption Schemes Secure against Adaptive Chosen Ciphertext Attack . Shoup later proposed it as an ISO standard in &#167;3.1 of A Proposal for an ISO Standard for Public Key Encryption . It was accepted as ISO 18033-2 and published in May 2006. KEMs are a building block of Hybrid Public Key Encryption (HPKE) . The NIST Post-Quantum Cryptography (PQC) standardization process explicitly calls for KEMs and digital signature algorithms to be evaluated as candidates for the next generation of standard public key cryptography algorithms. The Diffie-Hellman key exchange step in TLS 1.3 can also be modeled as a KEM. KEMs will be an important tool for defending against quantum attacks. None of the existing cryptographic APIs in the Java Platform is capable of representing KEMs in a natural way (see below ). Implementors of third-party security providers have already ex"
    }
  },
  {
    "url": "https://openjdk.org/jeps/400",
    "title": "JEP 400: UTF-8 by Default",
    "content": {
      "title": "JEP 400: UTF-8 by Default",
      "summary": "JEP 400: UTF-8 by Default JEP 400: UTF-8 by Default Authors Alan Bateman, Naoto Sato Owner Naoto Sato Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 18 Component core-libs&#8201;/&#8201;java.nio.charsets Discussion core dash libs dash dev at openjdk dot java dot net Effort XS Duration XS Reviewed by Alex Buckley, Brian Goetz Endorsed by Brian Goetz Created 2017/08/31 13:16 Updated 2025/04/14 07:28 Issue 8187041 Summary Specify UTF-8 as the default charset of the standard Jav",
      "sections": {
        "Summary": "Specify UTF-8 as the default charset of the standard Java APIs. With this change, APIs that depend upon the default charset will behave consistently across all implementations, operating systems, locales, and configurations.",
        "Goals": "Make Java programs more predictable and portable when their code relies on the default charset. Clarify where the standard Java API uses the default charset. Standardize on UTF-8 throughout the standard Java APIs, except for console I/O.",
        "Non-Goals": "It is not a goal to define new standard Java APIs or supported JDK APIs, although this effort may identify opportunities where new convenience methods might make existing APIs more approachable or easier to use. There is no intent to deprecate or remove standard Java APIs that rely on the default charset rather than taking an explicit charset parameter.",
        "Motivation": "Standard Java APIs for reading and writing files and for processing text allow a charset to be passed as an argument. A charset governs the conversion between raw bytes and the 16-bit char values of the Java programming language. Supported charsets include, for example, US-ASCII, UTF-8, and ISO-8859-1. If a charset argument is not passed, then standard Java APIs typically use the default charset . The JDK chooses the default charset at startup based upon the run-time environment: the operating system, the user's locale, and other factors. Because the default charset is not the same everywhere, APIs that use the default charset pose many non-obvious hazards, even to experienced developers. Consider an application that creates a java.io.FileWriter without passing a charset, and then uses it to write some text to a file. The resulting file will contain a sequence of bytes encoded using the default charset of the JDK running the application. A second application, run on a different machine",
        "Description": "In JDK 17 and earlier, the default charset is determined when the Java runtime starts. On macOS, it is UTF-8 except in the POSIX C locale. On other operating systems, it depends upon the user's locale and the default encoding, e.g., on Windows, it is a codepage-based charset such as windows-1252 or windows-31j . The method java.nio.charsets.Charset.defaultCharset() returns the default charset. A quick way to see the default charset of the current JDK is with the following command: java -XshowSettings:properties -version 2&gt;&amp;1 | grep file.encoding Several standard Java APIs use the default charset, including: In the java.io package, InputStreamReader , FileReader , OutputStreamWriter , FileWriter , and PrintStream define constructors to create readers, writers, and print streams that encode or decode using the default charset. In the java.util package, Formatter and Scanner define constructors whose results use the default charset. In the java.net package, URLEncoder and URLDecode",
        "Alternatives": "Preserve the status quo &#8212; This does not eliminate the hazards described above. Deprecate all methods in the Java API that use the default charset &#8212; This would encourage developers to use constructors and methods that take a charset parameter, but the resulting code would be more verbose. Specify UTF-8 as the default charset without providing any means to change it &#8212; The compatibility impact of this change would be too high. Installing Contributing Sponsoring Developers' Guide Vulnerabilities JDK GA/EA Builds Mailing lists Wiki &#183; IRC Mastodon Bluesky Bylaws &#183; Census Legal Workshop JEP Process Source code GitHub Mercurial Tools Git jtreg harness Groups (overview) Adoption Build Client Libraries Compatibility &amp;",
        "Testing": "Significant",
        "Risks and Assumptions": "below, we discuss how to mitigate the possible incompatibilities that arise from this change to file.encoding , as well as the native.encoding system property and recommendations for applications. There are three charset-related system properties used internally by the JDK. They remain unspecified and unsupported, but are documented here for completeness: sun.stdout.encoding and sun.stderr.encoding &#8212; the names of the charsets used for the standard output stream ( System.out ) and standard error stream ( System.err ), and in the java.io.Console API. sun.jnu.encoding &#8212; the name of the charset used by the implementation of java.nio.file when encoding or decoding filename paths, as opposed to file contents. On macOS its value is \"UTF-8\" ; on other platforms it is typically the default charset. Source file encoding The Java language allows source code to express Unicode characters in a UTF-16 encoding , and this is unaffected by the choice of UTF-8 for the default charset. Howev",
        "Specification": "of Charset.defaultCharset() to say that the default charset is UTF-8 unless configured otherwise by an implementation-specific means. (See below for how to configure the JDK.) The UTF-8 charset is specified by RFC 2279 ; the transformation format upon which it is based is specified in Amendment 2 of ISO 10646-1 and is also described in the Unicode Standard . It is not to be confused with Modified UTF-8 . We will update the"
      },
      "fullText": "JEP 400: UTF-8 by Default JEP 400: UTF-8 by Default Authors Alan Bateman, Naoto Sato Owner Naoto Sato Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 18 Component core-libs&#8201;/&#8201;java.nio.charsets Discussion core dash libs dash dev at openjdk dot java dot net Effort XS Duration XS Reviewed by Alex Buckley, Brian Goetz Endorsed by Brian Goetz Created 2017/08/31 13:16 Updated 2025/04/14 07:28 Issue 8187041 Summary Specify UTF-8 as the default charset of the standard Java APIs. With this change, APIs that depend upon the default charset will behave consistently across all implementations, operating systems, locales, and configurations. Goals Make Java programs more predictable and portable when their code relies on the default charset. Clarify where the standard Java API uses the default charset. Standardize on UTF-8 throughout the standard Java APIs, except for console I/O. Non-Goals It is not a goal to define new standard Java APIs or supported JDK APIs, although this effort may identify opportunities where new convenience methods might make existing APIs more approachable or easier to use. There is no intent to deprecate or remove standard Java APIs that rely on the default charset rather than taking an explicit charset parameter. Motivation Standard Java APIs for reading and writing files and for processing text allow a charset to be passed as an argument. A charset governs the conversion between raw bytes and the 16-bit char values of the Java programming language. Supported charsets include, for example, US-ASCII, UTF-8, and ISO-8859-1. If a charset argument is not passed, then standard Java APIs typically use the default charset . The JDK chooses the default charset at startup based upon the run-time environment: the operating system, the user's locale, and other factors. Because the default charset is not the same everywhere, APIs that use the default charset pose many non-obvious hazards, even to experienced developers. Consider an application that creates a java.io.FileWriter without passing a charset, and then uses it to write some text to a file. The resulting file will contain a sequence of bytes encoded using the default charset of the JDK running the application. A second application, run on a different machine or by a different user on the same machine, creates a java.io.FileReader without passing a charset and uses it to read the bytes in that file. The resulting text contains a sequence of characters decoded using the default charset of the JDK running the second application. If the default charset differs between the JDK of the first application and the JDK of the second application then the resulting text may be silently corrupted or incomplete, since the FileReader cannot tell that it decoded the text using the wrong charset relative to the FileWriter . Here is an example of this hazard, where a Japanese text file encoded in UTF-8 on macOS is corrupted when read on Windows in US-English or Japanese lo"
    }
  },
  {
    "url": "https://openjdk.org/jeps/418",
    "title": "JEP 418: Internet-Address Resolution SPI",
    "content": {
      "title": "JEP 418: Internet-Address Resolution SPI",
      "summary": "JEP 418: Internet-Address Resolution SPI JEP 418: Internet-Address Resolution SPI Owner Aleksej Efimov Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 18 Component core-libs&#8201;/&#8201;java.net Discussion net dash dev at openjdk dot java dot net Duration S Reviewed by Alan Bateman, Brian Goetz, Chris Hegarty, Daniel Fuchs Endorsed by Brian Goetz Created 2021/03/16 16:43 Updated 2022/09/09 10:29 Issue 8263693 Summary Define a service-provider interface (SPI) for host name a",
      "sections": {
        "Summary": "Define a service-provider interface (SPI) for host name and address resolution, so that java.net.InetAddress can make use of resolvers other than the platform's built-in resolver.",
        "Goals": "It is not a goal to develop an alternative resolver to include in the JDK. The JDK's built-in resolver will continue to be used by default. It is not a goal for the SPI to support resolution operations beyond those required by the InetAddress API. It is not a goal to define non-blocking or asynchronous resolution APIs.",
        "Non-Goals": "It is not a goal to develop an alternative resolver to include in the JDK. The JDK's built-in resolver will continue to be used by default. It is not a goal for the SPI to support resolution operations beyond those required by the InetAddress API. It is not a goal to define non-blocking or asynchronous resolution APIs.",
        "Motivation": "The java.net.InetAddress API resolves host names to Internet Protocol (IP) addresses, and vice versa. The API currently uses the operating system's native resolver, which is typically configured to use a combination of a local hosts file and the Domain Name System (DNS).",
        "Description": "The InetAddress API defines multiple methods for lookup operations: InetAddress::getAllByName performs a forward lookup, mapping a host name to a set of IP addresses. InetAddress::getByName also performs a forward lookup, mapping a host name to the first address in its set of addresses. InetAddress::getCanonicalHostName performs a reverse lookup, mapping an IP address to a fully qualified domain name. For example: var addressBytes = new byte[] { (byte) 192, 0, 43, 7}; var resolvedHostName = InetAddress.getByAddress(addressBytes) .getCanonicalHostName(); InetAddress::getHostName also performs a reverse lookup, if needed. By default, InetAddress uses the operating system's native resolver to perform lookups. The result of that lookup, whether positive or negative, may be cached in order to avoid further lookups of the same host. Service-provider interface The InetAddress API will use a service loader to locate a resolver provider. If no provider is found, the built-in implementation will",
        "Alternatives": "Without an SPI such as the one proposed here, applications will have to continue to use the workarounds available today. An application can use the Java Naming and Directory Interface (JNDI) and its DNS provider to look up network names and addresses. This approach can be useful for applications that require fine control of DNS lookups, but it is decoupled from InetAddress and thus using it with the platform's networking API requires additional effort. An application can use the operating system's resolver libraries directly via the Java Native Interface (JNI) or the foreign function API from Project Panama . As with JNDI, however, this approach is decoupled from InetAddress and thus more awkward to use. An application can use the non-standard, JDK-specific system property jdk.net.hosts.file to configure InetAddress to use a specific file, rather than the operating system's native resolver, to map host names to IP addresses. This feature is useful for",
        "Testing": "&#8212; Prototyping and",
        "Specification": "Review Compiler Conformance Core Libraries Governing Board HotSpot IDE Tooling &amp; Support Internationalization JMX Members Networking Porters Quality Security Serviceability Vulnerability Web Projects ( overview , archive ) Amber Babylon CRaC Code Tools Coin Common VM Interface Developers' Guide Device I/O Duke Galahad Graal IcedTea JDK 8 Updates JDK 9 JDK (&#8230;, 24 , 25 , 26 ) JDK Updates JMC Jigsaw Kona Lanai Leyden Lilliput Locale Enhancement Loom Memory Model Update Metropolis Multi-Language VM Nashorn New I/O OpenJFX Panama Penrose Port: AArch32 Port: AArch64 Port: BSD Port: Haiku Port: Mac OS X Port: MIPS Port: Mobile Port: PowerPC/AIX Port: RISC-V Port: s390x SCTP Shenandoah Skara Sumatra Tsan Valhalla Verona VisualVM Wakefield Zero ZGC &#169; 2025 Oracle Corporation and/or its affiliates Terms of Use &#183; License: GPLv2 &#183; Privacy &#183; Trademarks"
      },
      "fullText": "JEP 418: Internet-Address Resolution SPI JEP 418: Internet-Address Resolution SPI Owner Aleksej Efimov Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 18 Component core-libs&#8201;/&#8201;java.net Discussion net dash dev at openjdk dot java dot net Duration S Reviewed by Alan Bateman, Brian Goetz, Chris Hegarty, Daniel Fuchs Endorsed by Brian Goetz Created 2021/03/16 16:43 Updated 2022/09/09 10:29 Issue 8263693 Summary Define a service-provider interface (SPI) for host name and address resolution, so that java.net.InetAddress can make use of resolvers other than the platform's built-in resolver. Non-Goals It is not a goal to develop an alternative resolver to include in the JDK. The JDK's built-in resolver will continue to be used by default. It is not a goal for the SPI to support resolution operations beyond those required by the InetAddress API. It is not a goal to define non-blocking or asynchronous resolution APIs. Motivation The java.net.InetAddress API resolves host names to Internet Protocol (IP) addresses, and vice versa. The API currently uses the operating system's native resolver, which is typically configured to use a combination of a local hosts file and the Domain Name System (DNS). Motivations for defining a service-provider interface for name and address resolution include: Project Loom &#8212; A resolution operation with the InetAddress API currently blocks in an operating-system call. This is a problem for Loom's user-mode virtual threads, since it prevents underlying platform threads from servicing other virtual threads while waiting for a resolution operation to complete. An alternative resolver could implement the DNS client protocol directly, without blocking. Emerging network protocols &#8212; A resolver SPI would enable the seamless integration of new resolution protocols such as DNS over QUIC, TLS, or HTTPS. Customization &#8212; A resolver SPI would enable frameworks and applications to have finer control over resolution results, and would allow existing libraries to be retrofitted with a custom resolver. Testing &#8212; Prototyping and testing activities often require control of host name and address resolution results, for example when mocking components that use the InetAddress API. Description The InetAddress API defines multiple methods for lookup operations: InetAddress::getAllByName performs a forward lookup, mapping a host name to a set of IP addresses. InetAddress::getByName also performs a forward lookup, mapping a host name to the first address in its set of addresses. InetAddress::getCanonicalHostName performs a reverse lookup, mapping an IP address to a fully qualified domain name. For example: var addressBytes = new byte[] { (byte) 192, 0, 43, 7}; var resolvedHostName = InetAddress.getByAddress(addressBytes) .getCanonicalHostName(); InetAddress::getHostName also performs a reverse lookup, if needed. By default, InetAddress uses the operating system's native resolver to perform lookups. "
    }
  },
  {
    "url": "https://openjdk.org/jeps/408",
    "title": "JEP 408: Simple Web Server",
    "content": {
      "title": "JEP 408: Simple Web Server",
      "summary": "JEP 408: Simple Web Server JEP 408: Simple Web Server Owner Julia Boes Type Feature Scope JDK Status Closed&#8201;/&#8201;Delivered Release 18 Component core-libs&#8201;/&#8201;java.net Discussion net dash dev at openjdk dot java dot net Effort S Duration S Reviewed by Alex Buckley, Brian Goetz, Chris Hegarty, Daniel Fuchs Endorsed by Brian Goetz Created 2021/01/27 12:47 Updated 2022/03/07 10:20 Issue 8260510 Summary Provide a command-line tool to start a minimal web server that serves static fi",
      "sections": {
        "Summary": "Provide a command-line tool to start a minimal web server that serves static files only. No CGI or servlet-like functionality is available. This tool will be useful for prototyping, ad-hoc coding, and",
        "Goals": "Offer an out-of-the-box static HTTP file server with easy setup and minimal functionality. Reduce developer activation energy and make the JDK more approachable. Provide a default implementation via the command line together with a small API for programmatic creation and customization.",
        "Non-Goals": "It is not a goal to provide a feature-rich or commercial-grade server. Far better",
        "Motivation": "A common rite of passage for developers is to serve a file on the web, likely a &#8220;Hello, world!&#8221; HTML file. Most computer science curricula introduce students to web development, where local",
        "Description": "The Simple Web Server is a minimal HTTP server for serving a single directory hierarchy. It is based on the web server implementation in the com.sun.net.httpserver package that has been included in the JDK since 2006. The package is officially supported, and we extend it with APIs to simplify server creation and enhance request handling. The Simple Web Server can be used via the dedicated command-line tool jwebserver or programmatically via its API. Command-line tool The following command starts the Simple Web Server: $ jwebserver If startup is successful then jwebserver prints a message to System.out listing the local address and the absolute path of the directory being served. For example: $ jwebserver Binding to loopback by default. For all interfaces use \"-b 0.0.0.0\" or \"-b ::\". Serving /cwd and subdirectories on 127.0.0.1 port 8000 URL: http://127.0.0.1:8000/ By default, the server runs in the foreground and binds to the loopback address and port 8000. This can be changed with the",
        "Alternatives": "exist in the form of server frameworks (e.g., Jetty, Netty, and Grizzly) and production servers (e.g., Apache Tomcat, Apache httpd, and NGINX). These full-fledged and performance-optimized technologies take effort to configure, which is exactly what we want to avoid. It is not a goal to provide security features such as authentication, access control, or encryption. The server is intended solely for",
        "Testing": "purposes, particularly in educational contexts.",
        "Risks and Assumptions": "This simple server is intended for",
        "Specification": "Review Compiler Conformance Core Libraries Governing Board HotSpot IDE Tooling &amp; Support Internationalization JMX Members Networking Porters Quality Security Serviceability Vulnerability Web Projects ( overview , archive ) Amber Babylon CRaC Code Tools Coin Common VM Interface Developers' Guide Device I/O Duke Galahad Graal IcedTea JDK 8 Updates JDK 9 JDK (&#8230;, 24 , 25 , 26 ) JDK Updates JMC Jigsaw Kona Lanai Leyden Lilliput Locale Enhancement Loom Memory Model Update Metropolis Multi-Language VM Nashorn New I/O OpenJFX Panama Penrose Port: AArch32 Port: AArch64 Port: BSD Port: Haiku Port: Mac OS X Port: MIPS Port: Mobile Port: PowerPC/AIX Port: RISC-V Port: s390x SCTP Shenandoah Skara Sumatra Tsan Valhalla Verona VisualVM Wakefield Zero ZGC &#169; 2025 Oracle Corporation and/or its affiliates Terms of Use &#183; License: GPLv2 &#183; Privacy &#183; Trademarks"
      },
      "fullText": "JEP 408: Simple Web Server JEP 408: Simple Web Server Owner Julia Boes Type Feature Scope JDK Status Closed&#8201;/&#8201;Delivered Release 18 Component core-libs&#8201;/&#8201;java.net Discussion net dash dev at openjdk dot java dot net Effort S Duration S Reviewed by Alex Buckley, Brian Goetz, Chris Hegarty, Daniel Fuchs Endorsed by Brian Goetz Created 2021/01/27 12:47 Updated 2022/03/07 10:20 Issue 8260510 Summary Provide a command-line tool to start a minimal web server that serves static files only. No CGI or servlet-like functionality is available. This tool will be useful for prototyping, ad-hoc coding, and testing purposes, particularly in educational contexts. Goals Offer an out-of-the-box static HTTP file server with easy setup and minimal functionality. Reduce developer activation energy and make the JDK more approachable. Provide a default implementation via the command line together with a small API for programmatic creation and customization. Non-Goals It is not a goal to provide a feature-rich or commercial-grade server. Far better alternatives exist in the form of server frameworks (e.g., Jetty, Netty, and Grizzly) and production servers (e.g., Apache Tomcat, Apache httpd, and NGINX). These full-fledged and performance-optimized technologies take effort to configure, which is exactly what we want to avoid. It is not a goal to provide security features such as authentication, access control, or encryption. The server is intended solely for testing, development, and debugging. Accordingly, its design is explicitly minimal so as to avoid confusion with a full-featured server application. Motivation A common rite of passage for developers is to serve a file on the web, likely a &#8220;Hello, world!&#8221; HTML file. Most computer science curricula introduce students to web development, where local testing servers are commonly used. Developers usually also learn about system administration and web services, other areas where development tools with basic server functionality can come in handy. Educational and informal tasks such as these are where a small out-of-the-box server is desirable. Use cases include: Web development testing, where a local testing server is used to simulate a client-server set up. Web-service or application testing, where static files are used as API stubs in a directory structure that mirrors RESTful URLs and contains dummy data. Informal browsing and sharing of files across systems to, e.g., search a directory on a remote server from your local machine. In all these cases we can, of course, use a web-server framework, but that approach has a high activation energy: We have to look for options, pick one, download it, configure it, and figure out how to use it before we can serve our first request. These steps amount to quite a bit of ceremony, which is a drawback; getting stuck somewhere on the way can be frustrating and might even hinder the further use of Java. A basic web server spun up from the command line"
    }
  },
  {
    "url": "https://openjdk.org/jeps/416",
    "title": "JEP 416: Reimplement Core Reflection with Method Handles",
    "content": {
      "title": "JEP 416: Reimplement Core Reflection with Method Handles",
      "summary": "JEP 416: Reimplement Core Reflection with Method Handles JEP 416: Reimplement Core Reflection with Method Handles Owner Mandy Chung Type Feature Scope JDK Status Closed&#8201;/&#8201;Delivered Release 18 Component core-libs&#8201;/&#8201;java.lang:reflect Discussion core dash libs dash dev at openjdk dot java dot net Effort M Duration M Reviewed by Alan Bateman, John Rose Endorsed by John Rose Created 2021/04/26 22:41 Updated 2024/03/07 18:49 Issue 8266010 Summary Reimplement java.lang.reflect.M",
      "sections": {
        "Summary": "Reimplement java.lang.reflect.Method , Constructor , and Field on top of java.lang.invoke method handles. Making method handles the underlying mechanism for reflection will reduce the maintenance and development cost of both the java.lang.reflect and java.lang.invoke APIs.",
        "Goals": "It is not a goal to make any change to the java.lang.reflect API. This is solely an implementation change.",
        "Non-Goals": "It is not a goal to make any change to the java.lang.reflect API. This is solely an implementation change.",
        "Motivation": "Core reflection has two internal mechanisms for invoking methods and constructors. For fast startup, it uses native methods in the HotSpot VM for the first few invocations of a specific reflective method or constructor object. For better peak performance, after a number of invocations it generates bytecode for the reflective operation and uses that in subsequent invocations. For field access, core reflection uses the internal sun.misc.Unsafe API. With the java.lang.invoke method-handle API introduced in Java&#160;7, there are altogether three different internal mechanisms for reflective operations: VM native methods, Dynamically generated bytecode stubs for Method::invoke and Constructor::newInstance , along with Unsafe field access for Field::get and set , and Method handles. When we update java.lang.reflect and java.lang.invoke to support new language features, such as those envisioned in Project Valhalla , we must modify all three code paths, which is costly. In addition, the curren",
        "Description": "Reimplement java.lang.reflect on top of method handles as the common underlying reflective mechanism of the platform by replacing the bytecode-generating implementations of Method::invoke , Constructor::newInstance , Field::get , and Field::set . The new implementation performs direct invocations of the method handles for specific reflective objects. We use the VM's native reflection mechanism only during early VM startup, before the method-handle mechanism is initialized. That happens soon after System::initPhase1 and before System::initPhase2 , after which we switch to using method handles exclusively. This benefits Project Loom by reducing the use of native stack frames. For optimal performance, Method , Constructor , and Field instances should be held in static final fields so that they can be constant-folded by the JIT. When that is done, microbenchmarks show that the performance of the new implementation is significantly faster than the old implementation, by 43&#8211;57%. When M",
        "Alternatives": "Alternative 1: Do nothing Retain the existing core reflection implementation to avoid any compatibility risk. The dynamic bytecode generated for core reflection would remain at class file version 49, and the VM would continue to treat such bytecode specially. We reject this alternative because The cost of updating java.lang.reflect and java.lang.invoke to support Project Valhalla's primitive classes and generic specialization would be high, Additional special rules in the VM would likely be needed to support new language features within the limitation of the old class-file format, and Project Loom would need to find a way to handle the introduction of native stack frames by core reflection. Alternative 2: Upgrade to a new bytecode library Replace the bytecode writer used by core reflection to use a new bytecode library that evolves together with the class-file format, but otherwise retain the existing core reflection implementation and continue to treat dynamically-generated reflection",
        "Testing": "Comprehensive",
        "Risks and Assumptions": "Code that depends upon highly implementation-specific and undocumented aspects of the existing implementation may be impacted. To mitigate this compatibility risk, as a workaround you can enable the old implementation via -Djdk.reflect.useDirectMethodHandle=false . Code that inspects the internal generated reflection classes (i.e., subclasses of MagicAccessorImpl ) will no longer work and must be updated. Method-handle invocation may consume more resources than the old core reflection implementation. Such invocation involves calling multiple Java methods to ensure that the declaring class of a member is initialized prior to access, and thus may require more stack space for the necessary execution frames. This may result in a StackOverflowError or, if a StackOverflowError is thrown while initializing a class, then a NoClassDefFoundError . We will remove the old core reflection implementation in a future release. The -Djdk.reflect.useDirectMethodHandle=false workaround will stop working ",
        "Specification": "Review Compiler Conformance Core Libraries Governing Board HotSpot IDE Tooling &amp; Support Internationalization JMX Members Networking Porters Quality Security Serviceability Vulnerability Web Projects ( overview , archive ) Amber Babylon CRaC Code Tools Coin Common VM Interface Developers' Guide Device I/O Duke Galahad Graal IcedTea JDK 8 Updates JDK 9 JDK (&#8230;, 24 , 25 , 26 ) JDK Updates JMC Jigsaw Kona Lanai Leyden Lilliput Locale Enhancement Loom Memory Model Update Metropolis Multi-Language VM Nashorn New I/O OpenJFX Panama Penrose Port: AArch32 Port: AArch64 Port: BSD Port: Haiku Port: Mac OS X Port: MIPS Port: Mobile Port: PowerPC/AIX Port: RISC-V Port: s390x SCTP Shenandoah Skara Sumatra Tsan Valhalla Verona VisualVM Wakefield Zero ZGC &#169; 2025 Oracle Corporation and/or its affiliates Terms of Use &#183; License: GPLv2 &#183; Privacy &#183; Trademarks"
      },
      "fullText": "JEP 416: Reimplement Core Reflection with Method Handles JEP 416: Reimplement Core Reflection with Method Handles Owner Mandy Chung Type Feature Scope JDK Status Closed&#8201;/&#8201;Delivered Release 18 Component core-libs&#8201;/&#8201;java.lang:reflect Discussion core dash libs dash dev at openjdk dot java dot net Effort M Duration M Reviewed by Alan Bateman, John Rose Endorsed by John Rose Created 2021/04/26 22:41 Updated 2024/03/07 18:49 Issue 8266010 Summary Reimplement java.lang.reflect.Method , Constructor , and Field on top of java.lang.invoke method handles. Making method handles the underlying mechanism for reflection will reduce the maintenance and development cost of both the java.lang.reflect and java.lang.invoke APIs. Non-Goals It is not a goal to make any change to the java.lang.reflect API. This is solely an implementation change. Motivation Core reflection has two internal mechanisms for invoking methods and constructors. For fast startup, it uses native methods in the HotSpot VM for the first few invocations of a specific reflective method or constructor object. For better peak performance, after a number of invocations it generates bytecode for the reflective operation and uses that in subsequent invocations. For field access, core reflection uses the internal sun.misc.Unsafe API. With the java.lang.invoke method-handle API introduced in Java&#160;7, there are altogether three different internal mechanisms for reflective operations: VM native methods, Dynamically generated bytecode stubs for Method::invoke and Constructor::newInstance , along with Unsafe field access for Field::get and set , and Method handles. When we update java.lang.reflect and java.lang.invoke to support new language features, such as those envisioned in Project Valhalla , we must modify all three code paths, which is costly. In addition, the current implementation relies on special treatment by the VM of the generated bytecode, which is wrapped in subclasses of jdk.internal.reflect.MagicAccessorImpl : Accessibility is relaxed so that these classes can access inaccessible fields and methods of other classes, Verification is disabled to work around JLS &#167;6.6.2 in order to support reflection on Object::clone , and A non-well-behaved class loader is used to work around some security and compatibility issues. Description Reimplement java.lang.reflect on top of method handles as the common underlying reflective mechanism of the platform by replacing the bytecode-generating implementations of Method::invoke , Constructor::newInstance , Field::get , and Field::set . The new implementation performs direct invocations of the method handles for specific reflective objects. We use the VM's native reflection mechanism only during early VM startup, before the method-handle mechanism is initialized. That happens soon after System::initPhase1 and before System::initPhase2 , after which we switch to using method handles exclusively. This benefits Project Loom by reduc"
    }
  },
  {
    "url": "https://openjdk.org/jeps/413",
    "title": "JEP 413: Code Snippets in Java API Documentation",
    "content": {
      "title": "JEP 413: Code Snippets in Java API Documentation",
      "summary": "JEP 413: Code Snippets in Java API Documentation JEP 413: Code Snippets in Java API Documentation Authors Jonathan Gibbons, Pavel Rappo Owner Pavel Rappo Type Feature Scope JDK Status Closed&#8201;/&#8201;Delivered Release 18 Component tools&#8201;/&#8201;javadoc(tool) Discussion javadoc dash dev at openjdk dot java dot net Reviewed by Alex Buckley Created 2018/04/13 10:54 Updated 2025/05/05 21:06 Issue 8201533 Summary Introduce an @snippet tag for JavaDoc's Standard Doclet, to simplify the incl",
      "sections": {
        "Summary": "Introduce an @snippet tag for JavaDoc's Standard Doclet, to simplify the inclusion of example source code in API documentation.",
        "Goals": "Facilitate the validation of source code fragments, by providing API access to those fragments. Although correctness is ultimately the responsibility of the author, enhanced support in javadoc and related tools can make it easier to achieve. Enable modern styling, such as syntax highlighting, as well as the automatic linkage of names to declarations. Enable better IDE support for creating and editing snippets.",
        "Non-Goals": "It is not a goal for the javadoc tool itself to be able to validate, compile, or run any source code fragments. That task is left to external tools. It is not a goal to provide tests to validate the code fragments in the existing JDK API documentation, though we expect that a parallel effort will do so. It is not a goal to support interactive code examples at this time. Although we do not rule out such support in future, any such support will require external infrastructure that is beyond the scope of this proposal. Success Metrics Demonstrate the ability to replace most if not all uses of &lt;pre&gt;{@code ...}&lt;/pre&gt; blocks in key JDK modules with basic instances of the new tag, perhaps by using an automated conversion utility. (Reviewing and committing these changes, and manually editing selected examples to use more advanced features of the tag, is out of scope.)",
        "Motivation": "Authors of API documentation frequently include fragments of source code in documentation comments. Although {@code ...} can be used by itself for small fragments of code, non-trivial fragments are typically included in documentation comments with this compound pattern: &lt;pre&gt;{@code lines of source code }&lt;/pre&gt; When the javadoc tool is run over this documentation comment, the standard doclet will render HTML that precisely reflects the body of the {@code ...} tag, including indentation and without validating the code. For example, the source code of java.util.Stream includes a documentation comment that shows the use of a stream . There are various shortcomings to this approach. There is no way for tools to reliably detect code fragments, in order to check their validity. Moreover, the fragments are often incomplete, with placeholder comments and ellipses for the reader to fill in the blanks. With no way to check each fragment, errors can easily occur and are often seen in p",
        "Description": "The @snippet tag We introduce a new inline tag, {@snippet ...} , to declare code fragments to appear in the generated documentation. It can be used to declare both inline snippets , where the code fragment is included within the tag itself, and external snippets , where the code fragment is read from a separate source file. Additional details about the snippet can be given as attributes , in the form of name = value pairs, placed after the initial tag name. An attribute name is always a simple identifier. An attribute value may be enclosed in either single or double quote characters; no escape characters are supported. Attributes are separated from the tag name and from each other by whitespace characters, such as space and newline. A snippet may specify an id attribute, which can be used to identify the snippet in both the API and the generated HTML, and which may be used to create a link to the snippet. In the generated HTML, the id will be placed on the outermost element that is gen",
        "Alternatives": "Various third-party JavaScript solutions provide syntax highlighting. However, the JDK API documentation often includes examples involving new language features, and these may not be supported by such solutions in a timely manner. In addition, such solutions are typically based on regular expressions, which can be very fragile, and cannot leverage additional knowledge available when the documentation is generated. We considered using block comments to specify markup in the snippet content. However, block comments for markup are visually intrusive in the source code, and can only be used in external snippets. We considered using text blocks to enclose the content of inline snippets. However, that would be inconsistent with existing inline tags that accept textual content, and to follow the full",
        "Testing": "We will test this feature using the standard test infrastructure for javadoc features, including jtreg tests and related tools to check the correctness of the generated documentation. We will also convert existing simple &lt;pre&gt;{@code ...}&lt;/pre&gt; blocks to simple snippets in existing documentation. Installing Contributing Sponsoring Developers' Guide Vulnerabilities JDK GA/EA Builds Mailing lists Wiki &#183; IRC Mastodon Bluesky Bylaws &#183; Census Legal Workshop JEP Process Source code GitHub Mercurial Tools Git jtreg harness Groups (overview) Adoption Build Client Libraries Compatibility &amp;",
        "Specification": "for text blocks it would introduce additional rules about escape sequences. It would also make it harder to use text blocks as actual content in an inline snippet."
      },
      "fullText": "JEP 413: Code Snippets in Java API Documentation JEP 413: Code Snippets in Java API Documentation Authors Jonathan Gibbons, Pavel Rappo Owner Pavel Rappo Type Feature Scope JDK Status Closed&#8201;/&#8201;Delivered Release 18 Component tools&#8201;/&#8201;javadoc(tool) Discussion javadoc dash dev at openjdk dot java dot net Reviewed by Alex Buckley Created 2018/04/13 10:54 Updated 2025/05/05 21:06 Issue 8201533 Summary Introduce an @snippet tag for JavaDoc's Standard Doclet, to simplify the inclusion of example source code in API documentation. Goals Facilitate the validation of source code fragments, by providing API access to those fragments. Although correctness is ultimately the responsibility of the author, enhanced support in javadoc and related tools can make it easier to achieve. Enable modern styling, such as syntax highlighting, as well as the automatic linkage of names to declarations. Enable better IDE support for creating and editing snippets. Non-Goals It is not a goal for the javadoc tool itself to be able to validate, compile, or run any source code fragments. That task is left to external tools. It is not a goal to provide tests to validate the code fragments in the existing JDK API documentation, though we expect that a parallel effort will do so. It is not a goal to support interactive code examples at this time. Although we do not rule out such support in future, any such support will require external infrastructure that is beyond the scope of this proposal. Success Metrics Demonstrate the ability to replace most if not all uses of &lt;pre&gt;{@code ...}&lt;/pre&gt; blocks in key JDK modules with basic instances of the new tag, perhaps by using an automated conversion utility. (Reviewing and committing these changes, and manually editing selected examples to use more advanced features of the tag, is out of scope.) Motivation Authors of API documentation frequently include fragments of source code in documentation comments. Although {@code ...} can be used by itself for small fragments of code, non-trivial fragments are typically included in documentation comments with this compound pattern: &lt;pre&gt;{@code lines of source code }&lt;/pre&gt; When the javadoc tool is run over this documentation comment, the standard doclet will render HTML that precisely reflects the body of the {@code ...} tag, including indentation and without validating the code. For example, the source code of java.util.Stream includes a documentation comment that shows the use of a stream . There are various shortcomings to this approach. There is no way for tools to reliably detect code fragments, in order to check their validity. Moreover, the fragments are often incomplete, with placeholder comments and ellipses for the reader to fill in the blanks. With no way to check each fragment, errors can easily occur and are often seen in practice. Fragments using this pattern cannot reasonably be presented with syntax highlighting, which is nowadays a common e"
    }
  },
  {
    "url": "https://openjdk.org/jeps/430",
    "title": "JEP 430: String Templates (Preview)",
    "content": {
      "title": "JEP 430: String Templates (Preview)",
      "summary": "JEP 430: String Templates (Preview) JEP 430: String Templates (Preview) Owner Jim Laskey Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component specification&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Effort M Duration M Relates to JEP 459: String Templates (Second Preview) Reviewed by Alex Buckley, Brian Goetz, Maurizio Cimadamore Endorsed by Brian Goetz Created 2021/09/17 13:41 Updated 2023/10/13 13:52 Issue 8273943 Summary Enhance the Java pr",
      "sections": {
        "Summary": "Enhance the Java programming language with string templates . String templates complement Java's existing string literals and text blocks by coupling literal text with embedded expressions and template processors to produce specialized results. This is a preview language feature and API .",
        "Goals": "Simplify the writing of Java programs by making it easy to express strings that include values computed at run time. Enhance the readability of expressions that mix text and expressions, whether the text fits on a single source line (as with string literals) or spans several source lines (as with text blocks). Improve the security of Java programs that compose strings from user-provided values and pass them to other systems (e.g., building queries for databases) by supporting validation and transformation of both the template and the values of its embedded expressions. Retain flexibility by allowing Java libraries to define the formatting syntax used in string templates. Simplify the use of APIs that accept strings written in non-Java languages (e.g., SQL, XML, and JSON). Enable the creation of non-string values computed from literal text and embedded expressions without having to transit through an intermediate string representation.",
        "Non-Goals": "It is not a goal to introduce syntactic sugar for Java's string concatenation operator ( + ), since that would circumvent the goal of validation. It is not a goal to deprecate or remove the StringBuilder and StringBuffer classes, which have traditionally been used for complex or programmatic string composition.",
        "Motivation": "Developers routinely compose strings from a combination of literal text and expressions. Java provides several mechanisms for string composition, though unfortunately all have drawbacks. String concatenation with the + operator produces hard-to-read code: String s = x + \" plus \" + y + \" equals \" + (x + y); StringBuilder is verbose: String s = new StringBuilder() .append(x) .append(\" plus \") .append(y) .append(\" equals \") .append(x + y) .toString(); String::format and String::formatted separate the format string from the parameters, inviting arity and type mismatches: String s = String.format(\"%2$d plus %1$d equals %3$d\", x, y, x + y); String t = \"%2$d plus %1$d equals %3$d\".formatted(x, y, x + y); java.text.MessageFormat requires too much ceremony and uses an unfamiliar syntax in the format string: MessageFormat mf = new MessageFormat(\"{0} plus {1} equals {2}\"); String s = mf.format(x, y, x + y); String interpolation Many programming languages offer string interpolation as an alternati",
        "Description": "Template expressions are a new kind of expression in the Java programming language. Template expressions can perform string interpolation but are also programmable in a way that helps developers compose strings safely and efficiently. In addition, template expressions are not limited to composing strings &#8212; they can turn structured text into any kind of object, according to domain-specific rules. Syntactically, a template expression resembles a string literal with a prefix. There is a template expression on the second line of this code: String name = \"Joan\"; String info = STR.\"My name is \\{name}\"; assert info.equals(\"My name is Joan\"); // true The template expression STR.\"My name is \\{name}\" consists of: A template processor ( STR ); A dot character (U+002E), as seen in other kinds of expressions; and A template ( \"My name is \\{name}\" ) which contains an embedded expression ( \\{name} ). When a template expression is evaluated at run time, its template processor combines the litera",
        "Alternatives": "When a string template appears without a template processor then we could simply perform basic interpolation. However, this choice would violate the safety goal. It would be too tempting to construct SQL queries using interpolation, for example, and this would in the aggregate reduce the safety of Java programs. Always requiring a template processor ensures that the developer at least recognizes the possibility of domain-specific rules in a string template. The syntax of template expressions &#8212; with the template processor appearing first &#8212; is not strictly necessary. It would be possible to denote the template processor as an argument to StringTemplate::process . For example: String s = \"The answer is %5d\\{i}\".process(FMT); Having the template processor appear first is preferable because the result of evaluating the template expression is entirely dependent on the operation of the template processor. For the syntax of embedded expressions we considered using ${...} , but that",
        "Risks and Assumptions": "The implementation of java.util.FormatProcessor depends strongly upon java.util.Formatter , which may require a significant rewrite. Installing Contributing Sponsoring Developers' Guide Vulnerabilities JDK GA/EA Builds Mailing lists Wiki &#183; IRC Mastodon Bluesky Bylaws &#183; Census Legal Workshop JEP Process Source code GitHub Mercurial Tools Git jtreg harness Groups (overview) Adoption Build Client Libraries Compatibility &amp;",
        "Specification": "&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Effort M Duration M Relates to JEP 459: String Templates (Second Preview) Reviewed by Alex Buckley, Brian Goetz, Maurizio Cimadamore Endorsed by Brian Goetz Created 2021/09/17 13:41 Updated 2023/10/13 13:52 Issue 8273943"
      },
      "fullText": "JEP 430: String Templates (Preview) JEP 430: String Templates (Preview) Owner Jim Laskey Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component specification&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Effort M Duration M Relates to JEP 459: String Templates (Second Preview) Reviewed by Alex Buckley, Brian Goetz, Maurizio Cimadamore Endorsed by Brian Goetz Created 2021/09/17 13:41 Updated 2023/10/13 13:52 Issue 8273943 Summary Enhance the Java programming language with string templates . String templates complement Java's existing string literals and text blocks by coupling literal text with embedded expressions and template processors to produce specialized results. This is a preview language feature and API . Goals Simplify the writing of Java programs by making it easy to express strings that include values computed at run time. Enhance the readability of expressions that mix text and expressions, whether the text fits on a single source line (as with string literals) or spans several source lines (as with text blocks). Improve the security of Java programs that compose strings from user-provided values and pass them to other systems (e.g., building queries for databases) by supporting validation and transformation of both the template and the values of its embedded expressions. Retain flexibility by allowing Java libraries to define the formatting syntax used in string templates. Simplify the use of APIs that accept strings written in non-Java languages (e.g., SQL, XML, and JSON). Enable the creation of non-string values computed from literal text and embedded expressions without having to transit through an intermediate string representation. Non-Goals It is not a goal to introduce syntactic sugar for Java's string concatenation operator ( + ), since that would circumvent the goal of validation. It is not a goal to deprecate or remove the StringBuilder and StringBuffer classes, which have traditionally been used for complex or programmatic string composition. Motivation Developers routinely compose strings from a combination of literal text and expressions. Java provides several mechanisms for string composition, though unfortunately all have drawbacks. String concatenation with the + operator produces hard-to-read code: String s = x + \" plus \" + y + \" equals \" + (x + y); StringBuilder is verbose: String s = new StringBuilder() .append(x) .append(\" plus \") .append(y) .append(\" equals \") .append(x + y) .toString(); String::format and String::formatted separate the format string from the parameters, inviting arity and type mismatches: String s = String.format(\"%2$d plus %1$d equals %3$d\", x, y, x + y); String t = \"%2$d plus %1$d equals %3$d\".formatted(x, y, x + y); java.text.MessageFormat requires too much ceremony and uses an unfamiliar syntax in the format string: MessageFormat mf = new MessageFormat(\"{0} plus {1} equals {2}\"); String s = mf.format(x, y, x + y); String interpolation Many prog"
    }
  },
  {
    "url": "https://openjdk.org/jeps/445",
    "title": "JEP 445: Unnamed Classes and Instance Main Methods (Preview)",
    "content": {
      "title": "JEP 445: Unnamed Classes and Instance Main Methods (Preview)",
      "summary": "JEP 445: Unnamed Classes and Instance Main Methods (Preview) JEP 445: Unnamed Classes and Instance Main Methods (Preview) Author Ron Pressler Owner Jim Laskey Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component specification&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Effort S Relates to JEP 463: Implicitly Declared Classes and Instance Main Methods (Second Preview) Reviewed by Alex Buckley, Brian Goetz Endorsed by Brian Goetz Created 2023/02/",
      "sections": {
        "Summary": "Evolve the Java language so that students can write their first programs without needing to understand language features designed for large programs. Far from using a separate dialect of Java, students can write streamlined declarations for single-class programs and then seamlessly expand their programs to use more advanced features as their skills grow. This is a preview language feature .",
        "Goals": "Offer a smooth on-ramp to Java so that educators can introduce programming concepts in a gradual manner. Help students to write basic programs in a concise manner and grow their code gracefully as their skills grow. Reduce the ceremony of writing simple programs such as scripts and command-line utilities. Do not introduce a separate beginner's dialect of Java. Do not introduce a separate beginners' toolchain; student programs should be compiled and run with the same tools that compile and run any Java program.",
        "Motivation": "Java is a multi-paradigm language that excels for large, complex applications developed and maintained over many years by large teams. It has rich features for data hiding, reuse, access control, namespace management, and modularity which allow components to be cleanly composed while being developed and maintained independently. With these features components can expose well-defined interfaces for their interaction with other components and hide internal implementation details to permit the independent evolution of each. Indeed, the object-oriented paradigm itself is designed for plugging together pieces that interact through well-defined protocols and abstract away implementation details. This composition of large components is called programming in the large . Java also offers many constructs useful for programming in the small &#8212; everything that is internal to a component. In recent years, Java has enhanced both its programming-in-the-large capabilities with modules and its pro",
        "Description": "First, we enhance the protocol by which Java programs are launched to allow instance main methods . Such methods are not static , need not be public , and need not have a String[] parameter. Then we can simplify the Hello, World! program to: class HelloWorld { void main() { System.out.println(\"Hello, World!\"); } } Second, we introduce unnamed classes to make the class declaration implicit: void main() { System.out.println(\"Hello, World!\"); } This is preview language feature , disabled by default To try the examples below in JDK 21 you must enable preview features as follows: Compile the program with javac --release 21 --enable-preview Main.java and run it with java --enable-preview Main ; or, When using the source code launcher , run the program with java --source 21 --enable-preview Main.java The launch protocol New programmers want to write and run a computer program, but the Java Language",
        "Alternatives": "Use JShell for introductory programming &#8212; A JShell session is not a program but a sequence of code snippets. Declarations typed into jshell are implicitly viewed as static members of some unspecified class, with some unspecified access level, and statements execute in a context in which all previous declarations are in scope. This is convenient for experimentation &#8212; which is the primary use case for JShell &#8212; but not a good model for learning to write Java programs. Evolving a batch of working declarations in JShell into a real Java program leads to a non-idiomatic style of code because it declares each method, class, and variable as static . JShell is a great tool for exploration and debugging, but it is not the on-ramp programming model we are looking for. Interpret code units as static members &#8212; Methods and fields are non- static by default. Interpreting top-level members in an unnamed class as static would change the meaning of the code units in such a class ",
        "Dependencies": "in the form of a module path or a class path (or both), loading the class, initializing it, and invoking the main method with its arguments constitute the launch protocol . In the JDK it is implemented by the launcher , i.e., the java executable. A flexible launch protocol We enhance the launch protocol to offer more flexibility in the declaration of a program's entry point and, in particular, to allow instance main methods, as follows: Allow the main method of a launched class to have public , protected , or default (i.e., package) access. If a launched class contains no static main method with a String[] parameter but does contain a static main method with no parameters, then invoke that method. If a launched class has no static main method but has a non- private zero-parameter constructor (i.e., of public , protected , or package access), and a non- private instance main method, then construct an instance of the class. If the class has an instance main method with a String[] paramet",
        "Specification": "&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Effort S Relates to JEP 463: Implicitly Declared Classes and Instance Main Methods (Second Preview) Reviewed by Alex Buckley, Brian Goetz Endorsed by Brian Goetz Created 2023/02/13 13:58 Updated 2023/11/09 13:24 Issue 8302326"
      },
      "fullText": "JEP 445: Unnamed Classes and Instance Main Methods (Preview) JEP 445: Unnamed Classes and Instance Main Methods (Preview) Author Ron Pressler Owner Jim Laskey Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component specification&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Effort S Relates to JEP 463: Implicitly Declared Classes and Instance Main Methods (Second Preview) Reviewed by Alex Buckley, Brian Goetz Endorsed by Brian Goetz Created 2023/02/13 13:58 Updated 2023/11/09 13:24 Issue 8302326 Summary Evolve the Java language so that students can write their first programs without needing to understand language features designed for large programs. Far from using a separate dialect of Java, students can write streamlined declarations for single-class programs and then seamlessly expand their programs to use more advanced features as their skills grow. This is a preview language feature . Goals Offer a smooth on-ramp to Java so that educators can introduce programming concepts in a gradual manner. Help students to write basic programs in a concise manner and grow their code gracefully as their skills grow. Reduce the ceremony of writing simple programs such as scripts and command-line utilities. Do not introduce a separate beginner's dialect of Java. Do not introduce a separate beginners' toolchain; student programs should be compiled and run with the same tools that compile and run any Java program. Motivation Java is a multi-paradigm language that excels for large, complex applications developed and maintained over many years by large teams. It has rich features for data hiding, reuse, access control, namespace management, and modularity which allow components to be cleanly composed while being developed and maintained independently. With these features components can expose well-defined interfaces for their interaction with other components and hide internal implementation details to permit the independent evolution of each. Indeed, the object-oriented paradigm itself is designed for plugging together pieces that interact through well-defined protocols and abstract away implementation details. This composition of large components is called programming in the large . Java also offers many constructs useful for programming in the small &#8212; everything that is internal to a component. In recent years, Java has enhanced both its programming-in-the-large capabilities with modules and its programming-in-the-small capabilities with data-oriented programming . Java is also, however, intended to be a first programming language. When programmers first start out they do not write large programs, in a team &#8212; they write small programs, alone. They have no need for encapsulation and namespaces, useful to separately evolve components written by different people. When teaching programming, instructors start with the basic programming-in-the-small concepts of variables, control flow, and subroutines. At "
    }
  },
  {
    "url": "https://openjdk.org/jeps/443",
    "title": "JEP 443: Unnamed Patterns and Variables (Preview)",
    "content": {
      "title": "JEP 443: Unnamed Patterns and Variables (Preview)",
      "summary": "JEP 443: Unnamed Patterns and Variables (Preview) JEP 443: Unnamed Patterns and Variables (Preview) Owner Angelos Bimpoudis Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component specification&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Effort S Duration S Relates to JEP 456: Unnamed Variables &amp; Patterns Reviewed by Alex Buckley Endorsed by Brian Goetz Created 2022/09/26 08:00 Updated 2023/12/12 19:23 Issue 8294349 Summary Enhance the Java la",
      "sections": {
        "Summary": "Enhance the Java language with unnamed patterns , which match a record component without stating the component's name or type, and unnamed variables , which can be initialized but not used. Both are denoted by an underscore character, _ . This is a preview language feature .",
        "Goals": "Improve the readability of record patterns by eliding unnecessary nested patterns. Improve the maintainability of all code by identifying variables that must be declared (e.g., in a catch clause) but will not be used.",
        "Non-Goals": "It is not a goal to allow unnamed fields or method parameters. It is not a goal to alter the semantics of local variables, e.g., in definite assignment analysis .",
        "Motivation": "Unused patterns Records ( JEP 395 ) and record patterns ( JEP 440 ) work together to streamline data processing. A record class aggregates the components of a data item into an instance, while code that receives an instance of a record class uses pattern matching with record patterns to disaggregate the instance into its components. For example: record Point(int x, int y) { } enum Color { RED, GREEN, BLUE } record ColoredPoint(Point p, Color c) { } ... new ColoredPoint(new Point(3,4), Color.GREEN) ... if (r instanceof ColoredPoint(Point p, Color c)) { ... p.x() ... p.y() ... } In this code, one part of the program creates a ColoredPoint instance while another part uses pattern matching with instanceof to test whether a variable is a ColoredPoint and, if so, extract its two components. Record patterns such as ColoredPoint(Point p, Color c) are pleasingly descriptive, but it is common for programs to need only some of the components for further processing. For example, the code above nee",
        "Description": "The unnamed pattern is denoted by an underscore character _ (U+005F). It allows the type and name of a record component to be elided in pattern matching; e.g., ... instanceof Point(int x, _) case Point(int x, _) An unnamed pattern variable is declared when the pattern variable in a type pattern is denoted by an underscore. It allows the identifier which follows the type or var in a type pattern to be elided; e.g., ... instanceof Point(int x, int _) case Point(int x, int _) An unnamed variable is declared when either the local variable in a local variable declaration statement, or an exception parameter in a catch clause, or a lambda parameter in a lambda expression is denoted by an underscore. It allows the identifier which follows the type or var in the statement or expression to be elided; e.g., int _ = q.remove(); ... } catch (NumberFormatException _) { ... (int x, int _) -&gt; x + x In the case of single-parameter lambda expressions, such as _ -&gt; \"NODATA\" , the unnamed variable ",
        "Alternatives": "It is possible to define an analogous concept of unnamed method parameters . However, this has some interactions with",
        "Risks and Assumptions": "We assume that very little existing and maintained code uses underscore as a variable name. Such code was almost certainly written for Java&#160;7 or earlier and cannot have been recompiled with Java&#160;9 or later. The risk to such code is a compile-time error when reading or writing a variable called _ and when declaring any other kind of entity (class, field, etc.) with the name _ . We assume that developers can modify such code to avoid using underscore as the name of a variable or any other kind of entity by, e.g., renaming _ to _1 . We expect developers of static analysis tools to realize the new role of underscore for unnamed variables and to avoid flagging the non-use of such variables in modern code.",
        "Specification": "&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Effort S Duration S Relates to JEP 456: Unnamed Variables &amp; Patterns Reviewed by Alex Buckley Endorsed by Brian Goetz Created 2022/09/26 08:00 Updated 2023/12/12 19:23 Issue 8294349"
      },
      "fullText": "JEP 443: Unnamed Patterns and Variables (Preview) JEP 443: Unnamed Patterns and Variables (Preview) Owner Angelos Bimpoudis Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component specification&#8201;/&#8201;language Discussion amber dash dev at openjdk dot org Effort S Duration S Relates to JEP 456: Unnamed Variables &amp; Patterns Reviewed by Alex Buckley Endorsed by Brian Goetz Created 2022/09/26 08:00 Updated 2023/12/12 19:23 Issue 8294349 Summary Enhance the Java language with unnamed patterns , which match a record component without stating the component's name or type, and unnamed variables , which can be initialized but not used. Both are denoted by an underscore character, _ . This is a preview language feature . Goals Improve the readability of record patterns by eliding unnecessary nested patterns. Improve the maintainability of all code by identifying variables that must be declared (e.g., in a catch clause) but will not be used. Non-Goals It is not a goal to allow unnamed fields or method parameters. It is not a goal to alter the semantics of local variables, e.g., in definite assignment analysis . Motivation Unused patterns Records ( JEP 395 ) and record patterns ( JEP 440 ) work together to streamline data processing. A record class aggregates the components of a data item into an instance, while code that receives an instance of a record class uses pattern matching with record patterns to disaggregate the instance into its components. For example: record Point(int x, int y) { } enum Color { RED, GREEN, BLUE } record ColoredPoint(Point p, Color c) { } ... new ColoredPoint(new Point(3,4), Color.GREEN) ... if (r instanceof ColoredPoint(Point p, Color c)) { ... p.x() ... p.y() ... } In this code, one part of the program creates a ColoredPoint instance while another part uses pattern matching with instanceof to test whether a variable is a ColoredPoint and, if so, extract its two components. Record patterns such as ColoredPoint(Point p, Color c) are pleasingly descriptive, but it is common for programs to need only some of the components for further processing. For example, the code above needs only p in the if block, not c . It is laborious to write out all the components of a record class every time we do such pattern matching. Furthermore, it is not visually clear that the Color component is irrelevant; this makes the condition in the if block harder to read, too. This is especially evident when record patterns are nested to extract data within components, such as: if (r instanceof ColoredPoint(Point(int x, int y), Color c)) { ... x ... y ... } We can use var to reduce the visual cost of the unnecessary component Color c , e.g., ColoredPoint(Point(int x, int y), var c) , but it would better to reduce the cost even further by omitting unnecessary components altogether. This would both simplify the task of writing record patterns and improve readability, by removing clutter from the code. As developers gain ex"
    }
  },
  {
    "url": "https://openjdk.org/jeps/442",
    "title": "JEP 442: Foreign Function &amp; Memory API (Third Preview)",
    "content": {
      "title": "JEP 442: Foreign Function &amp; Memory API (Third Preview)",
      "summary": "JEP 442: Foreign Function &amp; Memory API (Third Preview) JEP 442: Foreign Function &amp; Memory API (Third Preview) Owner Maurizio Cimadamore Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component core-libs Discussion panama dash dev at openjdk dot org Relates to JEP 434: Foreign Function &amp; Memory API (Second Preview) JEP 454: Foreign Function &amp; Memory API Reviewed by Alex Buckley, Jorn Vernee Endorsed by Mark Reinhold Created 2023/02/01 14:58 Updated 2023/09/",
      "sections": {
        "Summary": "Introduce an API by which Java programs can interoperate with code and data outside of the Java runtime. By efficiently invoking foreign functions (i.e., code outside the JVM), and by safely accessing foreign memory (i.e., memory not managed by the JVM), the API enables Java programs to call native libraries and process native data without the brittleness and danger of JNI. This is a preview API . History The Foreign Function &amp; Memory (FFM) API first previewed in JDK&#160;19 via JEP 424 , then previewed again in JDK&#160;20 via JEP 434 . This JEP proposes a third preview to incorporate refinements based on feedback. In this version we have: Centralized the management of the lifetimes of native segments in the Arena interface; Enhanced layout paths with a new element to dereference address layouts; Provided a linker option to optimize calls to functions that are short-lived and will not upcall to Java (e.g., clock_gettime ); Provided a fallback native linker implementation, based on",
        "Goals": "Ease of use &#8212; Replace the Java Native Interface ( JNI ) with a superior, pure-Java development model. Performance &#8212; Provide performance that is comparable to, if not better than, existing APIs such as JNI and sun.misc.Unsafe . Generality &#8212; Provide ways to operate on different kinds of foreign memory (e.g., native memory, persistent memory, and managed heap memory) and, over time, to accommodate other platforms (e.g., 32-bit x86) and foreign functions written in languages other than C (e.g., C++, Fortran). Safety &#8212; Allow programs to perform unsafe operations on foreign memory, but warn users about such operations by default.",
        "Non-Goals": "It is not a goal to Re-implement JNI on top of this API, or otherwise change JNI in any way; Re-implement legacy Java APIs, such as sun.misc.Unsafe , on top of this API; Provide tooling that mechanically generates Java code from native-code header files; or Change how Java applications that interact with native libraries are packaged and deployed (e.g., via multi-platform JAR files).",
        "Motivation": "The Java Platform has always offered a rich foundation to library and application developers who wish to reach beyond the JVM and interact with other platforms. Java APIs expose non-Java resources conveniently and reliably, whether to access remote data (JDBC), invoke web services (HTTP client), serve remote clients (NIO channels), or communicate with local processes (Unix-domain sockets). Unfortunately, Java developers still face significant obstacles in accessing an important kind of non-Java resource: code and data on the same machine as the JVM, but outside the Java runtime. Foreign memory Objects created with the new keyword are stored in the JVM's heap , where they are subject to garbage collection when no longer needed. However, the cost and unpredictability of garbage collection is unacceptable for performance-critical libraries such as Tensorflow , Ignite , Lucene , and Netty . They need to store data outside the heap, in off-heap memory which they allocate and deallocate them",
        "Description": "The Foreign Function &amp; Memory API (FFM API) defines classes and interfaces so that client code in libraries and applications can Control the allocation and deallocation of foreign memory ( MemorySegment , Arena , and SegmentAllocator ), Manipulate and access structured foreign memory ( MemoryLayout and VarHandle ), and Call foreign functions ( Linker , FunctionDescriptor , and SymbolLookup ). The FFM API resides in the java.lang.foreign package of the java.base module. Example As a brief example of using the FFM API, here is Java code that obtains a method handle for a C library function radixsort and then uses it to sort four strings which start life in a Java array (a few details are elided). Because the FFM API is a preview API , you must compile and run the code with preview features enabled, i.e., javac --release 21 --enable-preview ... and java --enable-preview ... . // 1. Find foreign function on the C library path Linker linker = Linker.nativeLinker(); SymbolLookup stdlib =",
        "Alternatives": "Keep using java.nio.ByteBuffer , sun.misc.Unsafe , JNI, and other third-party frameworks.",
        "Risks and Assumptions": "Creating an API to access foreign memory in a way that is both safe and efficient is a daunting task. Since the spatial and temporal checks described in the previous sections need to be performed upon every access, it is crucial that JIT compilers be able to optimize away these checks by, e.g., hoisting them outside of hot loops. The JIT implementations will likely require some work to ensure that uses of the API are as efficient and optimizable as uses of existing APIs such as ByteBuffer and Unsafe . The JIT implementations will also require work to ensure that uses of the native method handles retrieved from the API are at least as efficient and optimizable as uses of existing JNI native methods.",
        "Dependencies": "The Foreign Function &amp; Memory API can be used to access non-volatile memory, already possible via JEP 352 (Non-Volatile Mapped Byte Buffers) , in a more general and efficient way. The work described here will likely enable subsequent work to provide a tool, jextract , which, starting from the header files for a given native library, mechanically generates the native method handles required to interoperate with that library. This will further reduce the overhead of using native libraries from Java. Installing Contributing Sponsoring Developers' Guide Vulnerabilities JDK GA/EA Builds Mailing lists Wiki &#183; IRC Mastodon Bluesky Bylaws &#183; Census Legal Workshop JEP Process Source code GitHub Mercurial Tools Git jtreg harness Groups (overview) Adoption Build Client Libraries Compatibility &amp;",
        "Specification": "Review Compiler Conformance Core Libraries Governing Board HotSpot IDE Tooling &amp; Support Internationalization JMX Members Networking Porters Quality Security Serviceability Vulnerability Web Projects ( overview , archive ) Amber Babylon CRaC Code Tools Coin Common VM Interface Developers' Guide Device I/O Duke Galahad Graal IcedTea JDK 8 Updates JDK 9 JDK (&#8230;, 24 , 25 , 26 ) JDK Updates JMC Jigsaw Kona Lanai Leyden Lilliput Locale Enhancement Loom Memory Model Update Metropolis Multi-Language VM Nashorn New I/O OpenJFX Panama Penrose Port: AArch32 Port: AArch64 Port: BSD Port: Haiku Port: Mac OS X Port: MIPS Port: Mobile Port: PowerPC/AIX Port: RISC-V Port: s390x SCTP Shenandoah Skara Sumatra Tsan Valhalla Verona VisualVM Wakefield Zero ZGC &#169; 2025 Oracle Corporation and/or its affiliates Terms of Use &#183; License: GPLv2 &#183; Privacy &#183; Trademarks"
      },
      "fullText": "JEP 442: Foreign Function &amp; Memory API (Third Preview) JEP 442: Foreign Function &amp; Memory API (Third Preview) Owner Maurizio Cimadamore Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component core-libs Discussion panama dash dev at openjdk dot org Relates to JEP 434: Foreign Function &amp; Memory API (Second Preview) JEP 454: Foreign Function &amp; Memory API Reviewed by Alex Buckley, Jorn Vernee Endorsed by Mark Reinhold Created 2023/02/01 14:58 Updated 2023/09/27 16:27 Issue 8301625 Summary Introduce an API by which Java programs can interoperate with code and data outside of the Java runtime. By efficiently invoking foreign functions (i.e., code outside the JVM), and by safely accessing foreign memory (i.e., memory not managed by the JVM), the API enables Java programs to call native libraries and process native data without the brittleness and danger of JNI. This is a preview API . History The Foreign Function &amp; Memory (FFM) API first previewed in JDK&#160;19 via JEP 424 , then previewed again in JDK&#160;20 via JEP 434 . This JEP proposes a third preview to incorporate refinements based on feedback. In this version we have: Centralized the management of the lifetimes of native segments in the Arena interface; Enhanced layout paths with a new element to dereference address layouts; Provided a linker option to optimize calls to functions that are short-lived and will not upcall to Java (e.g., clock_gettime ); Provided a fallback native linker implementation, based on libffi , to facilitate porting; and Removed the VaList class. Goals Ease of use &#8212; Replace the Java Native Interface ( JNI ) with a superior, pure-Java development model. Performance &#8212; Provide performance that is comparable to, if not better than, existing APIs such as JNI and sun.misc.Unsafe . Generality &#8212; Provide ways to operate on different kinds of foreign memory (e.g., native memory, persistent memory, and managed heap memory) and, over time, to accommodate other platforms (e.g., 32-bit x86) and foreign functions written in languages other than C (e.g., C++, Fortran). Safety &#8212; Allow programs to perform unsafe operations on foreign memory, but warn users about such operations by default. Non-goals It is not a goal to Re-implement JNI on top of this API, or otherwise change JNI in any way; Re-implement legacy Java APIs, such as sun.misc.Unsafe , on top of this API; Provide tooling that mechanically generates Java code from native-code header files; or Change how Java applications that interact with native libraries are packaged and deployed (e.g., via multi-platform JAR files). Motivation The Java Platform has always offered a rich foundation to library and application developers who wish to reach beyond the JVM and interact with other platforms. Java APIs expose non-Java resources conveniently and reliably, whether to access remote data (JDBC), invoke web services (HTTP client), serve remote clients (NIO channels), or"
    }
  },
  {
    "url": "https://openjdk.org/jeps/446",
    "title": "JEP 446: Scoped Values (Preview)",
    "content": {
      "title": "JEP 446: Scoped Values (Preview)",
      "summary": "JEP 446: Scoped Values (Preview) JEP 446: Scoped Values (Preview) Author Andrew Haley &amp; Andrew Dinn Owner Andrew Haley Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component core-libs Discussion loom dash dev at openjdk dot org Relates to JEP 429: Scoped Values (Incubator) JEP 464: Scoped Values (Second Preview) Reviewed by Alan Bateman, Mark Reinhold Endorsed by Brian Goetz Created 2023/03/16 16:01 Updated 2023/11/29 14:41 Issue 8304357 Summary Introduce scoped val",
      "sections": {
        "Summary": "Introduce scoped values , values that may be safely and efficiently shared to methods without using method parameters. They are preferred to thread-local variables, especially when using large numbers of virtual threads. This is a preview API . In effect, a scoped value is an implicit method parameter . It is \"as if\" every method in a sequence of calls has an additional, invisible, parameter. None of the methods declare this parameter and only the methods that have access to the scoped value object can access its value (the data). Scoped values make it possible to pass data securely from a caller to a faraway callee through a sequence of intermediate methods that do not declare a parameter for the data and have no access to the data. History Scoped Values incubated in JDK 20 via JEP 429 . In JDK&#160;21 this feature is no longer incubating; instead, it is a preview API .",
        "Goals": "Ease of use &#8212; Provide a programming model to share data both within a thread and with child threads, so as to simplify reasoning about data flow. Comprehensibility &#8212; Make the lifetime of shared data visible from the syntactic structure of code. Robustness &#8212; Ensure that data shared by a caller can be retrieved only by legitimate callees. Performance &#8212; Allow shared data to be immutable so as to allow sharing by a large number of threads, and to enable runtime optimizations.",
        "Non-Goals": "It is not a goal to change the Java programming language. It is not a goal to require migration away from thread-local variables, or to deprecate the existing ThreadLocal API.",
        "Motivation": "Java applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls. Most methods allow a caller to pass data to a method by passing them as parameters. When method A wants method B to do some work for it, it invokes B with the appropriate parameters, and B may pass some of those parameters to C , etc. B may have to include in its parameter list not only the things B directly needs but also the things B has to pass to C . For example, if B is going to set up and execute a database call, it might want a Connection passed in, even if B is not going to use the Connection directly. Most of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call. An example It is a common pattern in large Java programs to transfer control from one component (",
        "Description": "A scoped value allows data to be safely and efficiently shared between methods in a large program without resorting to method arguments. It is a variable of type ScopedValue . Typically, it is declared as a final static field so it can easily be reached from many methods. Like a thread-local variable, a scoped value has multiple values associated with it, one per thread. The particular value that is used depends on which thread calls its methods. Unlike a thread-local variable, a scoped value is written once, and is available only for a bounded period during execution of the thread. A scoped value is used as shown below. Some code calls ScopedValue.where , presenting a scoped value and the object to which it is to be bound. The call to run binds the scoped value, providing a copy that is specific to the current thread, and then executes the lambda expression passed as argument. During the lifetime of the run call, the lambda expression, or any method called directly or indirectly from ",
        "Alternatives": "It is possible to emulate many of the features of scoped values with thread-local variables, albeit at some cost in memory footprint, security, and performance. We experimented with a modified version of ThreadLocal that supports some of the characteristics of scoped values. However, carrying the additional baggage of thread-local variables results in an implementation that is unduly burdensome, or an API that returns UnsupportedOperationException for much of its core functionality, or both. It is better, therefore, not to modify ThreadLocal but to introduce scoped values as an entirely separate concept. Scoped values were inspired by the way that many Lisp dialects provide support for dynamically scoped free variables; in particular, how such variables behave in a deep-bound, multi-threaded runtime such as Interlisp-D. scoped values improve on Lisp's free variables by adding type safety, immutability, encapsulation, and efficient access within and across threads. Installing Contributi",
        "Specification": "Review Compiler Conformance Core Libraries Governing Board HotSpot IDE Tooling &amp; Support Internationalization JMX Members Networking Porters Quality Security Serviceability Vulnerability Web Projects ( overview , archive ) Amber Babylon CRaC Code Tools Coin Common VM Interface Developers' Guide Device I/O Duke Galahad Graal IcedTea JDK 8 Updates JDK 9 JDK (&#8230;, 24 , 25 , 26 ) JDK Updates JMC Jigsaw Kona Lanai Leyden Lilliput Locale Enhancement Loom Memory Model Update Metropolis Multi-Language VM Nashorn New I/O OpenJFX Panama Penrose Port: AArch32 Port: AArch64 Port: BSD Port: Haiku Port: Mac OS X Port: MIPS Port: Mobile Port: PowerPC/AIX Port: RISC-V Port: s390x SCTP Shenandoah Skara Sumatra Tsan Valhalla Verona VisualVM Wakefield Zero ZGC &#169; 2025 Oracle Corporation and/or its affiliates Terms of Use &#183; License: GPLv2 &#183; Privacy &#183; Trademarks"
      },
      "fullText": "JEP 446: Scoped Values (Preview) JEP 446: Scoped Values (Preview) Author Andrew Haley &amp; Andrew Dinn Owner Andrew Haley Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component core-libs Discussion loom dash dev at openjdk dot org Relates to JEP 429: Scoped Values (Incubator) JEP 464: Scoped Values (Second Preview) Reviewed by Alan Bateman, Mark Reinhold Endorsed by Brian Goetz Created 2023/03/16 16:01 Updated 2023/11/29 14:41 Issue 8304357 Summary Introduce scoped values , values that may be safely and efficiently shared to methods without using method parameters. They are preferred to thread-local variables, especially when using large numbers of virtual threads. This is a preview API . In effect, a scoped value is an implicit method parameter . It is \"as if\" every method in a sequence of calls has an additional, invisible, parameter. None of the methods declare this parameter and only the methods that have access to the scoped value object can access its value (the data). Scoped values make it possible to pass data securely from a caller to a faraway callee through a sequence of intermediate methods that do not declare a parameter for the data and have no access to the data. History Scoped Values incubated in JDK 20 via JEP 429 . In JDK&#160;21 this feature is no longer incubating; instead, it is a preview API . Goals Ease of use &#8212; Provide a programming model to share data both within a thread and with child threads, so as to simplify reasoning about data flow. Comprehensibility &#8212; Make the lifetime of shared data visible from the syntactic structure of code. Robustness &#8212; Ensure that data shared by a caller can be retrieved only by legitimate callees. Performance &#8212; Allow shared data to be immutable so as to allow sharing by a large number of threads, and to enable runtime optimizations. Non-Goals It is not a goal to change the Java programming language. It is not a goal to require migration away from thread-local variables, or to deprecate the existing ThreadLocal API. Motivation Java applications and libraries are structured as collections of classes which contain methods. These methods communicate through method calls. Most methods allow a caller to pass data to a method by passing them as parameters. When method A wants method B to do some work for it, it invokes B with the appropriate parameters, and B may pass some of those parameters to C , etc. B may have to include in its parameter list not only the things B directly needs but also the things B has to pass to C . For example, if B is going to set up and execute a database call, it might want a Connection passed in, even if B is not going to use the Connection directly. Most of the time this \"pass what your indirect callees need\" approach is the most effective and convenient way to share data. However, sometimes it is impractical to pass all the data that every indirect callee might need in the initial call. An example It is a common pat"
    }
  },
  {
    "url": "https://openjdk.org/jeps/453",
    "title": "JEP 453: Structured Concurrency (Preview)",
    "content": {
      "title": "JEP 453: Structured Concurrency (Preview)",
      "summary": "JEP 453: Structured Concurrency (Preview) JEP 453: Structured Concurrency (Preview) Author Ron Pressler &amp; Alan Bateman Owner Alan Bateman Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component core-libs Discussion loom dash dev at openjdk dot org Relates to JEP 437: Structured Concurrency (Second Incubator) JEP 462: Structured Concurrency (Second Preview) Reviewed by Brian Goetz Endorsed by Brian Goetz Created 2023/04/21 06:18 Updated 2025/02/27 17:47 Issue 8306641 ",
      "sections": {
        "Summary": "Simplify concurrent programming by introducing an API for structured concurrency . Structured concurrency treats groups of related tasks running in different threads as a single unit of work, thereby streamlining error handling and cancellation, improving reliability, and enhancing observability. This is a preview API . History Structured Concurrency was proposed by JEP 428 and delivered in JDK&#160;19 as an incubating API. It was re-incubated by JEP&#160;437 in JDK&#160;20 with a minor update to inherit scoped values ( JEP&#160;429 ). We here propose to make Structured Concurrency a Preview API in the java.util.concurrent package. The only significant change is that the StructuredTaskScope :: fork(...) method returns a Subtask rather than a Future , as discussed below .",
        "Goals": "Promote a style of concurrent programming that can eliminate common risks arising from cancellation and shutdown, such as thread leaks and cancellation delays. Improve the observability of concurrent code.",
        "Non-Goals": "It is not a goal to replace any of the concurrency constructs in the java.util.concurrent package, such as ExecutorService and Future . It is not a goal to define the definitive structured concurrency API for the Java Platform. Other structured concurrency constructs can be defined by third-party libraries or in future JDK releases. It is not a goal to define a means of sharing streams of data among threads (i.e., channels ). We might propose to do so in the future. It is not a goal to replace the existing thread interruption mechanism with a new thread cancellation mechanism. We might propose to do so in the future.",
        "Motivation": "Developers manage complexity by breaking tasks down into multiple subtasks. In ordinary single-threaded code, the subtasks execute sequentially. However, if the subtasks are sufficiently independent of each other, and if there are sufficient hardware resources, then the overall task can be made to run faster (i.e., with lower latency) by executing the subtasks concurrently. For example, a task that composes the results of multiple I/O operations will run faster if each I/O operation executes concurrently in its own thread. Virtual threads ( JEP 444 ) make it cost-effective to dedicate a thread to every such I/O operation, but managing the huge number of threads that can result remains a challenge. Unstructured concurrency with ExecutorService The java.util.concurrent.ExecutorService API, introduced in Java 5, helps developers execute subtasks concurrently. For example here is a method, handle() , that represents a task in a server application. It handles an incoming request by submitti",
        "Description": "The principal class of the structured concurrency API is StructuredTaskScope in the java.util.concurrent package. This class allows developers to structure a task as a family of concurrent subtasks, and to coordinate them as a unit. Subtasks are executed in their own threads by forking them individually and then joining them as a unit and, possibly, cancelling them as a unit. The subtasks' successful results or exceptions are aggregated and handled by the parent task. StructuredTaskScope confines the lifetimes of the subtasks to a clear lexical scope in which all of a task's interactions with its subtasks &#8212; forking, joining, cancelling, handling errors, and composing results &#8212; takes place. Here is the handle() example from earlier, written to use StructuredTaskScope ( ShutdownOnFailure is explained below ): Response handle() throws ExecutionException, InterruptedException { try (var scope = new StructuredTaskScope.ShutdownOnFailure()) { Supplier&lt;String&gt; user = scope.f",
        "Alternatives": "Enhance the ExecutorService interface. We prototyped an implementation of this interface that always enforces structure and restricts which threads can submit tasks. However, we found it to be problematic because most uses of ExecutorService (and its parent interface Executor ) in the JDK and in the ecosystem are not structured. Reusing the same API for a far more restricted concept is bound to cause confusion. For example, passing a structured ExecutorService instance to existing methods that accept this type would be all but certain to throw exceptions in most situations. Installing Contributing Sponsoring Developers' Guide Vulnerabilities JDK GA/EA Builds Mailing lists Wiki &#183; IRC Mastodon Bluesky Bylaws &#183; Census Legal Workshop JEP Process Source code GitHub Mercurial Tools Git jtreg harness Groups (overview) Adoption Build Client Libraries Compatibility &amp;",
        "Specification": "Review Compiler Conformance Core Libraries Governing Board HotSpot IDE Tooling &amp; Support Internationalization JMX Members Networking Porters Quality Security Serviceability Vulnerability Web Projects ( overview , archive ) Amber Babylon CRaC Code Tools Coin Common VM Interface Developers' Guide Device I/O Duke Galahad Graal IcedTea JDK 8 Updates JDK 9 JDK (&#8230;, 24 , 25 , 26 ) JDK Updates JMC Jigsaw Kona Lanai Leyden Lilliput Locale Enhancement Loom Memory Model Update Metropolis Multi-Language VM Nashorn New I/O OpenJFX Panama Penrose Port: AArch32 Port: AArch64 Port: BSD Port: Haiku Port: Mac OS X Port: MIPS Port: Mobile Port: PowerPC/AIX Port: RISC-V Port: s390x SCTP Shenandoah Skara Sumatra Tsan Valhalla Verona VisualVM Wakefield Zero ZGC &#169; 2025 Oracle Corporation and/or its affiliates Terms of Use &#183; License: GPLv2 &#183; Privacy &#183; Trademarks"
      },
      "fullText": "JEP 453: Structured Concurrency (Preview) JEP 453: Structured Concurrency (Preview) Author Ron Pressler &amp; Alan Bateman Owner Alan Bateman Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 21 Component core-libs Discussion loom dash dev at openjdk dot org Relates to JEP 437: Structured Concurrency (Second Incubator) JEP 462: Structured Concurrency (Second Preview) Reviewed by Brian Goetz Endorsed by Brian Goetz Created 2023/04/21 06:18 Updated 2025/02/27 17:47 Issue 8306641 Summary Simplify concurrent programming by introducing an API for structured concurrency . Structured concurrency treats groups of related tasks running in different threads as a single unit of work, thereby streamlining error handling and cancellation, improving reliability, and enhancing observability. This is a preview API . History Structured Concurrency was proposed by JEP 428 and delivered in JDK&#160;19 as an incubating API. It was re-incubated by JEP&#160;437 in JDK&#160;20 with a minor update to inherit scoped values ( JEP&#160;429 ). We here propose to make Structured Concurrency a Preview API in the java.util.concurrent package. The only significant change is that the StructuredTaskScope :: fork(...) method returns a Subtask rather than a Future , as discussed below . Goals Promote a style of concurrent programming that can eliminate common risks arising from cancellation and shutdown, such as thread leaks and cancellation delays. Improve the observability of concurrent code. Non-Goals It is not a goal to replace any of the concurrency constructs in the java.util.concurrent package, such as ExecutorService and Future . It is not a goal to define the definitive structured concurrency API for the Java Platform. Other structured concurrency constructs can be defined by third-party libraries or in future JDK releases. It is not a goal to define a means of sharing streams of data among threads (i.e., channels ). We might propose to do so in the future. It is not a goal to replace the existing thread interruption mechanism with a new thread cancellation mechanism. We might propose to do so in the future. Motivation Developers manage complexity by breaking tasks down into multiple subtasks. In ordinary single-threaded code, the subtasks execute sequentially. However, if the subtasks are sufficiently independent of each other, and if there are sufficient hardware resources, then the overall task can be made to run faster (i.e., with lower latency) by executing the subtasks concurrently. For example, a task that composes the results of multiple I/O operations will run faster if each I/O operation executes concurrently in its own thread. Virtual threads ( JEP 444 ) make it cost-effective to dedicate a thread to every such I/O operation, but managing the huge number of threads that can result remains a challenge. Unstructured concurrency with ExecutorService The java.util.concurrent.ExecutorService API, introduced in Java 5, helps developers execute subtas"
    }
  },
  {
    "url": "https://openjdk.org/jeps/448",
    "title": "JEP 448: Vector API (Sixth Incubator)",
    "content": {
      "title": "JEP 448: Vector API (Sixth Incubator)",
      "summary": "JEP 448: Vector API (Sixth Incubator) JEP 448: Vector API (Sixth Incubator) Owner Paul Sandoz Type Feature Scope JDK Status Closed&#8201;/&#8201;Delivered Release 21 Component core-libs Discussion panama dash dev at openjdk dot org Effort S Duration S Relates to JEP 438: Vector API (Fifth Incubator) JEP 460: Vector API (Seventh Incubator) Reviewed by Vladimir Ivanov Endorsed by John Rose Created 2023/04/11 20:18 Updated 2024/04/09 18:05 Issue 8305868 Summary Introduce an API to express vector co",
      "sections": {
        "Summary": "Introduce an API to express vector computations that reliably compile at runtime to optimal vector instructions on supported CPU architectures, thus achieving performance superior to equivalent scalar computations. History The Vector API was first proposed by JEP 338 and integrated into JDK 16 as an incubating API . Further rounds of incubation were proposed by JEP 414 (integrated into JDK&#160;17), JEP 417 (JDK&#160;18), JEP 426 (JDK&#160;19), and JEP 438 (JDK&#160;20). This JEP proposes to re-incubate the API in JDK 21, with minor enhancements in the API relative to JDK&#160;20. The implementation includes bug fixes and performance enhancements. We include the following notable changes: Add the exclusive or (xor) operation to vector masks. Improve the performance of vector shuffles, especially when used to rearrange the elements of a vector and when converting between vectors.",
        "Goals": "Clear and concise API &#8212; The API should be capable of clearly and concisely expressing a wide range of vector computations consisting of sequences of vector operations composed within loops and possibly with control flow. It should be possible to express a computation that is generic with respect to vector size, or the number of lanes per vector, thus enabling such computations to be portable across hardware supporting different vector sizes. Platform agnostic &#8212; The API should be CPU architecture agnostic, enabling implementations on multiple architectures supporting vector instructions. As is usual in Java APIs, where platform optimization and portability conflict then we will bias toward making the API portable, even if that results in some platform-specific idioms not being expressible in portable code. Reliable runtime compilation and performance on x64 and AArch64 architectures &#8212; On capable x64 architectures the Java runtime, specifically the HotSpot C2 compiler, ",
        "Non-Goals": "It is not a goal to enhance the existing auto-vectorization algorithm in HotSpot. It is not a goal to support vector instructions on CPU architectures other than x64 and AArch64. However it is important to state, as expressed in the",
        "Motivation": "A vector computation consists of a sequence of operations on vectors. A vector comprises a (usually) fixed sequence of scalar values, where the scalar values correspond to the number of hardware-defined vector lanes. A binary operation applied to two vectors with the same number of lanes would, for each lane, apply the equivalent scalar operation on the corresponding two scalar values from each vector. This is commonly referred to as Single Instruction Multiple Data (SIMD). Vector operations express a degree of parallelism that enables more work to be performed in a single CPU cycle and thus can result in significant performance gains. For example, given two vectors, each containing a sequence of eight integers (i.e., eight lanes), the two vectors can be added together using a single hardware instruction. The vector addition instruction operates on sixteen integers, performing eight integer additions, in the time it would ordinarily take to operate on two integers, performing one integ",
        "Description": "A vector is represented by the abstract class Vector&lt;E&gt; . The type variable E is instantiated as the boxed type of the scalar primitive integral or floating point element types covered by the vector. A vector also has a shape which defines the size, in bits, of the vector. The shape of a vector governs how an instance of Vector&lt;E&gt; is mapped to a hardware vector register when vector computations are compiled by the HotSpot C2 compiler. The length of a vector, i.e., the number of lanes or elements, is the vector size divided by the element size. The set of element types ( E ) supported is Byte , Short , Integer , Long , Float and Double , corresponding to the scalar primitive types byte , short , int , long , float and double , respectively. The set of shapes supported correspond to vector sizes of 64, 128, 256, and 512 bits, as well as max bits. A 512-bit shape can pack byte s into 64 lanes or pack int s into 16 lanes, and a vector of such a shape can operate on 64 byte s at",
        "Alternatives": "HotSpot's auto-vectorization is an alternative approach, but it would require significant work. It would, moreover, still be fragile and limited compared to the Vector API, since auto-vectorization with complex control flow is very hard to perform. In general, even after decades of research &#8212; especially for FORTRAN and C array loops &#8212; it seems that auto-vectorization of scalar code is not a reliable tactic for optimizing ad-hoc user-written loops unless the user pays unusually careful attention to unwritten contracts about exactly which loops a compiler is prepared to auto-vectorize. It is too easy to write a loop that fails to auto-vectorize, for a reason that no human reader can detect. Years of work on auto-vectorization, even in HotSpot, have left us with lots of optimization machinery that works only on special occasions. We want to enjoy the use of this machinery more often!",
        "Testing": "We will develop combinatorial unit tests to ensure coverage for all operations, for all supported types and shapes, over various data sets. We will also develop performance tests to ensure that performance",
        "Risks and Assumptions": "There is a risk that the API will be biased to the SIMD functionality supported on x64 architectures, but this is mitigated with support for AArch64. This applies mainly to the explicitly fixed set of supported shapes, which bias against coding algorithms in a shape-generic fashion. We consider the majority of other operations of the Vector API to bias toward portable algorithms. To mitigate that risk we will take other architectures into account, specifically the ARM Scalar Vector Extension architecture whose programming model adjusts dynamically to the singular fixed shape supported by the hardware. We welcome and encourage OpenJDK contributors working on the ARM-specific areas of HotSpot to participate in this effort. The Vector API uses box types (e.g., Integer ) as proxies for primitive types (e.g., int ). This decision is forced by the current limitations of Java generics, which are hostile to primitive types. When Project Valhalla eventually introduces more capable generics then",
        "Specification": ". The Vector&lt;E&gt; class declares a set of methods for common vector operations supported by all element types. For operations specific to an element type there are six abstract subclasses of Vector&lt;E&gt; , one for each supported element type: ByteVector , ShortVector , IntVector , LongVector , FloatVector , and DoubleVector . These type-specific subclasses define additional operations that are bound to the element type since the method signature refers either to the element type or to the related array type. Examples of such operations include reduction (e.g., summing all lanes to a scalar value), and copying a vector's elements into an array. These subclasses also define additional full-service operations specific to the integral subtypes (e.g., bitwise operations such as logical or), as well as operations specific to the floating point types (e.g., transcendental mathematical functions such as exponentiation). As an implementation matter, these type-specific subclasses of Vect"
      },
      "fullText": "JEP 448: Vector API (Sixth Incubator) JEP 448: Vector API (Sixth Incubator) Owner Paul Sandoz Type Feature Scope JDK Status Closed&#8201;/&#8201;Delivered Release 21 Component core-libs Discussion panama dash dev at openjdk dot org Effort S Duration S Relates to JEP 438: Vector API (Fifth Incubator) JEP 460: Vector API (Seventh Incubator) Reviewed by Vladimir Ivanov Endorsed by John Rose Created 2023/04/11 20:18 Updated 2024/04/09 18:05 Issue 8305868 Summary Introduce an API to express vector computations that reliably compile at runtime to optimal vector instructions on supported CPU architectures, thus achieving performance superior to equivalent scalar computations. History The Vector API was first proposed by JEP 338 and integrated into JDK 16 as an incubating API . Further rounds of incubation were proposed by JEP 414 (integrated into JDK&#160;17), JEP 417 (JDK&#160;18), JEP 426 (JDK&#160;19), and JEP 438 (JDK&#160;20). This JEP proposes to re-incubate the API in JDK 21, with minor enhancements in the API relative to JDK&#160;20. The implementation includes bug fixes and performance enhancements. We include the following notable changes: Add the exclusive or (xor) operation to vector masks. Improve the performance of vector shuffles, especially when used to rearrange the elements of a vector and when converting between vectors. Goals Clear and concise API &#8212; The API should be capable of clearly and concisely expressing a wide range of vector computations consisting of sequences of vector operations composed within loops and possibly with control flow. It should be possible to express a computation that is generic with respect to vector size, or the number of lanes per vector, thus enabling such computations to be portable across hardware supporting different vector sizes. Platform agnostic &#8212; The API should be CPU architecture agnostic, enabling implementations on multiple architectures supporting vector instructions. As is usual in Java APIs, where platform optimization and portability conflict then we will bias toward making the API portable, even if that results in some platform-specific idioms not being expressible in portable code. Reliable runtime compilation and performance on x64 and AArch64 architectures &#8212; On capable x64 architectures the Java runtime, specifically the HotSpot C2 compiler, should compile vector operations to corresponding efficient and performant vector instructions, such as those supported by Streaming SIMD Extensions (SSE) and Advanced Vector Extensions (AVX). Developers should have confidence that the vector operations they express will reliably map closely to relevant vector instructions. On capable ARM AArch64 architectures C2 will, similarly, compile vector operations to the vector instructions supported by NEON and SVE . Graceful degradation &#8212; Sometimes a vector computation cannot be fully expressed at runtime as a sequence of vector instructions, perhaps because the architecture does no"
    }
  },
  {
    "url": "https://openjdk.org/jeps/449",
    "title": "JEP 449: Deprecate the Windows 32-bit x86 Port for Removal",
    "content": {
      "title": "JEP 449: Deprecate the Windows 32-bit x86 Port for Removal",
      "summary": "JEP 449: Deprecate the Windows 32-bit x86 Port for Removal JEP 449: Deprecate the Windows 32-bit x86 Port for Removal Author George Adams &amp; Bruno Borges Owner George Adams Type Feature Scope Implementation Status Closed&#8201;/&#8201;Delivered Release 21 Component hotspot&#8201;/&#8201;other Discussion jdk dash dev at openjdk dot org Effort S Duration S Relates to JEP 479: Remove the Windows 32-bit x86 Port JEP 501: Deprecate the 32-bit x86 Port for Removal Reviewed by Jesper Wilhelmsson End",
      "sections": {
        "Summary": "Deprecate the Windows 32-bit x86 port, with the intent to remove it in a future release.",
        "Goals": "Update the build system to issue an error message when an attempt is made to configure a build for Windows 32-bit x86 (x86-32). The error message will be suppressible via a new configuration option. Mark the port, and related port-specific features, as deprecated for removal in the relevant documentation.",
        "Non-Goals": "It is not a goal to change the status of the affected port in any prior release. The earliest release to which this JEP could be targeted is JDK&#160;21. It is not a goal to deprecate any other 32-bit port.",
        "Motivation": "Allow contributors in the OpenJDK Community to accelerate the development of new features and enhancements that will move the platform forward. The implementation of JEP 436 (Virtual Threads) for Windows x86-32 falls back to the use of kernel threads and therefore does not bring the expected benefits of Project Loom. Windows 10, the last Windows operating system to support 32-bit operation, will reach End of Life in October 2025 .",
        "Description": "An attempt to configure a Windows x86-32 build will produce the following output: $ bash ./configure ... checking compilation type... native configure: error: The Windows 32-bit x86 port is deprecated and may be removed in a future release. \\ Use --enable-deprecated-ports=yes to suppress this error. configure exiting with result code 1 $ The new build configuration option --enable-deprecated-ports=yes will suppress the error and continue: $ bash ./configure --enable-deprecated-ports=yes ... checking compilation type... native configure: WARNING: The Windows 32-bit x86 port is deprecated and may be removed in a future release. ... Build performance",
        "Alternatives": "The alternative would be to continue to support Windows x86-32. This would require active maintainers who can provide a sustainable and performant implementation of Virtual Threads, as well as future JEPs, to ensure that the JDK on Windows x86-32 continues to meet the expectations of Java developers.",
        "Risks and Assumptions": "32-bit JVMs are still used on Windows due to integration with 32-bit native libraries (DLLs). Their users cannot migrate directly to 64-bit JVMs because a 64-bit process on Windows cannot load 32-bit DLLs. While Windows x64 is capable of running 32-bit applications by emulating an 32-bit environment through WOW64 , applications will suffer dramatic performance degradation despite the assumed memory footprint benefits. We therefore assume that Users can continue to run existing builds of the Windows 32-bit JVM to integrate with native 32-bit libraries and, if necessary, expose 32-bit functionality via remote APIs to be consumed by applications running on a 64-bit JVM within the same environment; and Legacy systems are unlikely to migrate to versions of the JDK following the release of Java 21. Installing Contributing Sponsoring Developers' Guide Vulnerabilities JDK GA/EA Builds Mailing lists Wiki &#183; IRC Mastodon Bluesky Bylaws &#183; Census Legal Workshop JEP Process Source code Git",
        "Specification": "Review Compiler Conformance Core Libraries Governing Board HotSpot IDE Tooling &amp; Support Internationalization JMX Members Networking Porters Quality Security Serviceability Vulnerability Web Projects ( overview , archive ) Amber Babylon CRaC Code Tools Coin Common VM Interface Developers' Guide Device I/O Duke Galahad Graal IcedTea JDK 8 Updates JDK 9 JDK (&#8230;, 24 , 25 , 26 ) JDK Updates JMC Jigsaw Kona Lanai Leyden Lilliput Locale Enhancement Loom Memory Model Update Metropolis Multi-Language VM Nashorn New I/O OpenJFX Panama Penrose Port: AArch32 Port: AArch64 Port: BSD Port: Haiku Port: Mac OS X Port: MIPS Port: Mobile Port: PowerPC/AIX Port: RISC-V Port: s390x SCTP Shenandoah Skara Sumatra Tsan Valhalla Verona VisualVM Wakefield Zero ZGC &#169; 2025 Oracle Corporation and/or its affiliates Terms of Use &#183; License: GPLv2 &#183; Privacy &#183; Trademarks"
      },
      "fullText": "JEP 449: Deprecate the Windows 32-bit x86 Port for Removal JEP 449: Deprecate the Windows 32-bit x86 Port for Removal Author George Adams &amp; Bruno Borges Owner George Adams Type Feature Scope Implementation Status Closed&#8201;/&#8201;Delivered Release 21 Component hotspot&#8201;/&#8201;other Discussion jdk dash dev at openjdk dot org Effort S Duration S Relates to JEP 479: Remove the Windows 32-bit x86 Port JEP 501: Deprecate the 32-bit x86 Port for Removal Reviewed by Jesper Wilhelmsson Endorsed by Dalibor Topic, Vladimir Kozlov Created 2023/02/24 15:30 Updated 2024/10/24 11:25 Issue 8303167 Summary Deprecate the Windows 32-bit x86 port, with the intent to remove it in a future release. Goals Update the build system to issue an error message when an attempt is made to configure a build for Windows 32-bit x86 (x86-32). The error message will be suppressible via a new configuration option. Mark the port, and related port-specific features, as deprecated for removal in the relevant documentation. Non-Goals It is not a goal to change the status of the affected port in any prior release. The earliest release to which this JEP could be targeted is JDK&#160;21. It is not a goal to deprecate any other 32-bit port. Motivation Allow contributors in the OpenJDK Community to accelerate the development of new features and enhancements that will move the platform forward. The implementation of JEP 436 (Virtual Threads) for Windows x86-32 falls back to the use of kernel threads and therefore does not bring the expected benefits of Project Loom. Windows 10, the last Windows operating system to support 32-bit operation, will reach End of Life in October 2025 . Description An attempt to configure a Windows x86-32 build will produce the following output: $ bash ./configure ... checking compilation type... native configure: error: The Windows 32-bit x86 port is deprecated and may be removed in a future release. \\ Use --enable-deprecated-ports=yes to suppress this error. configure exiting with result code 1 $ The new build configuration option --enable-deprecated-ports=yes will suppress the error and continue: $ bash ./configure --enable-deprecated-ports=yes ... checking compilation type... native configure: WARNING: The Windows 32-bit x86 port is deprecated and may be removed in a future release. ... Build performance summary: * Cores to use: 32 * Memory limit: 96601 MB The following warnings were produced. Repeated here for convenience: WARNING: The Windows 32-bit x86 port is deprecated and may be removed in a future release. $ Alternatives The alternative would be to continue to support Windows x86-32. This would require active maintainers who can provide a sustainable and performant implementation of Virtual Threads, as well as future JEPs, to ensure that the JDK on Windows x86-32 continues to meet the expectations of Java developers. Risks and Assumptions 32-bit JVMs are still used on Windows due to integration with 32-bit native libraries (DLLs). Their use"
    }
  },
  {
    "url": "https://openjdk.org/jeps/421",
    "title": "JEP 421: Deprecate Finalization for Removal",
    "content": {
      "title": "JEP 421: Deprecate Finalization for Removal",
      "summary": "JEP 421: Deprecate Finalization for Removal JEP 421: Deprecate Finalization for Removal Authors Brent Christian, Stuart Marks Owner Brent Christian Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 18 Component core-libs&#8201;/&#8201;java.lang Discussion core dash libs dash dev at openjdk dot java dot net Effort S Duration S Reviewed by Alex Buckley, Brian Goetz, Kim Barrett Endorsed by Brian Goetz, Mikael Vidstedt Created 2021/09/30 20:24 Updated 2025/03/07 15:16 Issue 827460",
      "sections": {
        "Summary": "Deprecate finalization for removal in a future release. Finalization remains enabled by default for now, but can be disabled to facilitate early",
        "Goals": "Help developers understand the dangers of finalization. Prepare developers for the removal of finalization in a future version of the Java Platform. Provide simple tooling to help detect reliance upon finalization.",
        "Motivation": "Resource leaks Java programs enjoy automatic memory management, wherein the JVM's garbage collector (GC) reclaims the memory used by an object when the object is no longer needed. However, some objects represent a resource provided by the operating system, such as an open file descriptor or a block of native memory. For such objects, it is insufficient merely to reclaim the object's memory; the program must also release the underlying resource back to the operating system, typically by calling the object's close method. If the program fails to do this before the GC reclaims the object then the information needed to release the resource is lost. The resource, still considered by the operating system to be in use, has leaked . Resource leaks can be surprisingly common. Consider the following code that copies data from one file to another. In early versions of Java, developers typically used the try-finally construct to ensure that resources were released even if an exception occurred whi",
        "Description": "We propose to: Add a command-line option to disable finalization, so that no finalizers are ever scheduled by the GC to run, and Deprecate all finalizers, and finalization-related methods, in the standard Java API. Note that finalization is distinct from both the final modifier and the finally block of the try-finally construct. No changes are proposed to either final or try-finally . Command-line option to disable finalization Finalization remains enabled by default in JDK 18. A new command-line option --finalization=disabled disables finalization. A JVM launched with --finalization=disabled will not run any finalizers &#8212; not even those declared within the JDK itself. You can use the option to help determine if your application relies on finalization, and to test how it will behave once finalization is removed. For example, you could first run an application load test without the option, so that finalization is enabled, and record metrics such as: Memory profiles for Java heap an",
        "Testing": ". In a future release it will be disabled by default, and in a later release it will be removed. Maintainers of libraries and applications that rely upon finalization should consider migrating to other resource management techniques such as the try -with-resources statement and cleaners .",
        "Specification": "when we remove finalization, since finalizers interact with the Java Memory Model. Installing Contributing Sponsoring Developers' Guide Vulnerabilities JDK GA/EA Builds Mailing lists Wiki &#183; IRC Mastodon Bluesky Bylaws &#183; Census Legal Workshop JEP Process Source code GitHub Mercurial Tools Git jtreg harness Groups (overview) Adoption Build Client Libraries Compatibility &amp;"
      },
      "fullText": "JEP 421: Deprecate Finalization for Removal JEP 421: Deprecate Finalization for Removal Authors Brent Christian, Stuart Marks Owner Brent Christian Type Feature Scope SE Status Closed&#8201;/&#8201;Delivered Release 18 Component core-libs&#8201;/&#8201;java.lang Discussion core dash libs dash dev at openjdk dot java dot net Effort S Duration S Reviewed by Alex Buckley, Brian Goetz, Kim Barrett Endorsed by Brian Goetz, Mikael Vidstedt Created 2021/09/30 20:24 Updated 2025/03/07 15:16 Issue 8274609 Summary Deprecate finalization for removal in a future release. Finalization remains enabled by default for now, but can be disabled to facilitate early testing. In a future release it will be disabled by default, and in a later release it will be removed. Maintainers of libraries and applications that rely upon finalization should consider migrating to other resource management techniques such as the try -with-resources statement and cleaners . Goals Help developers understand the dangers of finalization. Prepare developers for the removal of finalization in a future version of the Java Platform. Provide simple tooling to help detect reliance upon finalization. Motivation Resource leaks Java programs enjoy automatic memory management, wherein the JVM's garbage collector (GC) reclaims the memory used by an object when the object is no longer needed. However, some objects represent a resource provided by the operating system, such as an open file descriptor or a block of native memory. For such objects, it is insufficient merely to reclaim the object's memory; the program must also release the underlying resource back to the operating system, typically by calling the object's close method. If the program fails to do this before the GC reclaims the object then the information needed to release the resource is lost. The resource, still considered by the operating system to be in use, has leaked . Resource leaks can be surprisingly common. Consider the following code that copies data from one file to another. In early versions of Java, developers typically used the try-finally construct to ensure that resources were released even if an exception occurred while copying: FileInputStream input = null; FileOutputStream output = null; try { input = new FileInputStream(file1); output = new FileOutputStream(file2); ... copy bytes from input to output ... output.close(); output = null; input.close(); input = null; } finally { if (output != null) output.close(); if (input != null) input.close(); } This code is erroneous: If copying throws an exception, and if the output.close() statement in the finally block throws an exception, then the input stream will be leaked. Handling exceptions from all possible execution paths is laborious and difficult to get right. (The fix here involves a nested try-finally construct, and is left as an exercise for the reader.) Even if an unhandled exception occurs only occasionally, leaked resources can build up over time. Finalization &"
    }
  }
]